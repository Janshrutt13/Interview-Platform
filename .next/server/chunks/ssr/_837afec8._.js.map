{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        \"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        \"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]\",\n        \"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Input }\n"],"names":[],"mappings":";;;;;AAEA;;;AAEA,SAAS,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAsC;IACzE,qBACE,8OAAC;QACC,MAAM;QACN,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,8bACA,iFACA,0GACA;QAED,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 29, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Label({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  return (\n    <LabelPrimitive.Root\n      data-slot=\"label\"\n      className={cn(\n        \"flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Label }\n"],"names":[],"mappings":";;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,MAAM,EACb,SAAS,EACT,GAAG,OAC8C;IACjD,qBACE,8OAAC,yKAAmB;QAClB,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,uNACA;QAED,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 56, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { db } from \"@/firebase/admin\";\n\n// -------------------- START AXON SESSION --------------------\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType } = params;\n\n  try {\n    // Generate adaptive questions\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\",\n      prompt: `Generate 5 interview questions for a ${experience} level ${jobRole} position.\n\nRequirements:\n- Start with easier questions and progressively increase difficulty\n- Include behavioral, technical, and situational questions\n- Format as JSON array of strings\n- Questions should be realistic and commonly asked\n\nExample format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n    } catch {\n      questions = [\n        \"Tell me about yourself and your background.\",\n        \"Why are you interested in this role?\",\n        \"Describe a challenging project you've worked on.\",\n        \"How do you handle working under pressure?\",\n        \"Where do you see yourself in 5 years?\"\n      ];\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    await db.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\n// -------------------- GET INSTANT FEEDBACK --------------------\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\",\n      prompt: `CRITICAL EVALUATION REQUIRED - Analysis ID: ${Date.now()}\n\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily (give rating 1-3):\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n- One-word or extremely short answers\n\nOnly give high ratings (7-10) for:\n- Well-structured, coherent responses\n- Specific examples and concrete details\n- Proper use of relevant terminology\n- Clear demonstration of understanding\n- Answers that directly address the question\n\nProvide feedback in this JSON format:\n{\n  \"positives\": [\"ONLY list genuinely good points that actually address the question - if none exist, say 'No clear strengths identified'\"],\n  \"improvements\": [\"Be specific about what's wrong and how to fix it\"],\n  \"rating\": \"Score 1-10 - LOW (1-3) for poor/random answers, HIGH (7-10) only for genuinely good responses\"\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW rating and explain why it's inadequate.`\n    });\n\n    let feedback: any;\n    try {\n      // Extract JSON from markdown code blocks if present\n      let jsonText = feedbackText.trim();\n      if (jsonText.startsWith('```json')) {\n        jsonText = jsonText.replace(/```json\\s*/, '').replace(/\\s*```$/, '');\n      } else if (jsonText.startsWith('```')) {\n        jsonText = jsonText.replace(/```\\s*/, '').replace(/\\s*```$/, '');\n      }\n      \n      feedback = JSON.parse(jsonText);\n      // Ensure rating is a number and validate it\n      if (feedback.rating) {\n        const rating = parseInt(feedback.rating);\n        if (isNaN(rating) || rating < 1 || rating > 10) {\n          feedback.rating = \"3\"; // Default low rating for invalid responses\n        }\n      }\n    } catch (parseError) {\n      console.error(\"Failed to parse AI feedback:\", parseError);\n      // Default to critical feedback for parsing failures\n      feedback = {\n        positives: [\"No clear strengths identified\"],\n        improvements: [\"Response was unclear or incoherent. Please provide a structured answer that directly addresses the question with specific examples.\"],\n        rating: \"2\"\n      };\n    }\n\n    // Save the response with feedback\n    await db.collection(\"axon_sessions\")\n      .doc(sessionId)\n      .update({\n        responses: [\n          ...(sessionData?.responses || []),\n          {\n            questionIndex,\n            answer: textAnswer,\n            feedback,\n            timestamp: new Date()\n          }\n        ]\n      });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error generating feedback:\", error);\n    return { success: false, error: \"Failed to generate feedback\" };\n  }\n}\n\n// -------------------- END AXON SESSION --------------------\nexport async function endAxonSession(params: { sessionId: string; userId: string }) {\n  const { sessionId, userId } = params;\n\n  try {\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date()\n    });\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\n// -------------------- GET NEXT QUESTION --------------------\nexport async function getNextQuestion(params: { sessionId: string; currentIndex: number }) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= sessionData?.questions.length) {\n      return { success: true, isComplete: true };\n    }\n\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      isComplete: false,\n      question: sessionData?.questions[nextIndex],\n      questionIndex: nextIndex\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\n// -------------------- GET SESSION HISTORY --------------------\nexport async function getAxonSessionHistory(userId: string) {\n  try {\n    const sessionsQuery = await db.collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .orderBy(\"startTime\", \"desc\")\n      .limit(10)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error fetching session history:\", error);\n    return { success: false, error: \"Failed to fetch session history\" };\n  }\n}\n\n// -------------------- TYPE DEFINITIONS --------------------\ninterface StartAxonSessionParams {\n  userId: string;\n  jobRole: string;\n  experience: string;\n  sessionType: string;\n}\n\ninterface GetInstantFeedbackParams {\n  sessionId: string;\n  questionIndex: number;\n  textAnswer: string;\n  audioBlob?: Blob;\n  userId: string;\n}"],"names":[],"mappings":";;;;;;;IAOsB,mBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { db } from \"@/firebase/admin\";\n\n// -------------------- START AXON SESSION --------------------\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType } = params;\n\n  try {\n    // Generate adaptive questions\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\",\n      prompt: `Generate 5 interview questions for a ${experience} level ${jobRole} position.\n\nRequirements:\n- Start with easier questions and progressively increase difficulty\n- Include behavioral, technical, and situational questions\n- Format as JSON array of strings\n- Questions should be realistic and commonly asked\n\nExample format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n    } catch {\n      questions = [\n        \"Tell me about yourself and your background.\",\n        \"Why are you interested in this role?\",\n        \"Describe a challenging project you've worked on.\",\n        \"How do you handle working under pressure?\",\n        \"Where do you see yourself in 5 years?\"\n      ];\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    await db.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\n// -------------------- GET INSTANT FEEDBACK --------------------\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\",\n      prompt: `CRITICAL EVALUATION REQUIRED - Analysis ID: ${Date.now()}\n\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily (give rating 1-3):\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n- One-word or extremely short answers\n\nOnly give high ratings (7-10) for:\n- Well-structured, coherent responses\n- Specific examples and concrete details\n- Proper use of relevant terminology\n- Clear demonstration of understanding\n- Answers that directly address the question\n\nProvide feedback in this JSON format:\n{\n  \"positives\": [\"ONLY list genuinely good points that actually address the question - if none exist, say 'No clear strengths identified'\"],\n  \"improvements\": [\"Be specific about what's wrong and how to fix it\"],\n  \"rating\": \"Score 1-10 - LOW (1-3) for poor/random answers, HIGH (7-10) only for genuinely good responses\"\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW rating and explain why it's inadequate.`\n    });\n\n    let feedback: any;\n    try {\n      // Extract JSON from markdown code blocks if present\n      let jsonText = feedbackText.trim();\n      if (jsonText.startsWith('```json')) {\n        jsonText = jsonText.replace(/```json\\s*/, '').replace(/\\s*```$/, '');\n      } else if (jsonText.startsWith('```')) {\n        jsonText = jsonText.replace(/```\\s*/, '').replace(/\\s*```$/, '');\n      }\n      \n      feedback = JSON.parse(jsonText);\n      // Ensure rating is a number and validate it\n      if (feedback.rating) {\n        const rating = parseInt(feedback.rating);\n        if (isNaN(rating) || rating < 1 || rating > 10) {\n          feedback.rating = \"3\"; // Default low rating for invalid responses\n        }\n      }\n    } catch (parseError) {\n      console.error(\"Failed to parse AI feedback:\", parseError);\n      // Default to critical feedback for parsing failures\n      feedback = {\n        positives: [\"No clear strengths identified\"],\n        improvements: [\"Response was unclear or incoherent. Please provide a structured answer that directly addresses the question with specific examples.\"],\n        rating: \"2\"\n      };\n    }\n\n    // Save the response with feedback\n    await db.collection(\"axon_sessions\")\n      .doc(sessionId)\n      .update({\n        responses: [\n          ...(sessionData?.responses || []),\n          {\n            questionIndex,\n            answer: textAnswer,\n            feedback,\n            timestamp: new Date()\n          }\n        ]\n      });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error generating feedback:\", error);\n    return { success: false, error: \"Failed to generate feedback\" };\n  }\n}\n\n// -------------------- END AXON SESSION --------------------\nexport async function endAxonSession(params: { sessionId: string; userId: string }) {\n  const { sessionId, userId } = params;\n\n  try {\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date()\n    });\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\n// -------------------- GET NEXT QUESTION --------------------\nexport async function getNextQuestion(params: { sessionId: string; currentIndex: number }) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= sessionData?.questions.length) {\n      return { success: true, isComplete: true };\n    }\n\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      isComplete: false,\n      question: sessionData?.questions[nextIndex],\n      questionIndex: nextIndex\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\n// -------------------- GET SESSION HISTORY --------------------\nexport async function getAxonSessionHistory(userId: string) {\n  try {\n    const sessionsQuery = await db.collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .orderBy(\"startTime\", \"desc\")\n      .limit(10)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error fetching session history:\", error);\n    return { success: false, error: \"Failed to fetch session history\" };\n  }\n}\n\n// -------------------- TYPE DEFINITIONS --------------------\ninterface StartAxonSessionParams {\n  userId: string;\n  jobRole: string;\n  experience: string;\n  sessionType: string;\n}\n\ninterface GetInstantFeedbackParams {\n  sessionId: string;\n  questionIndex: number;\n  textAnswer: string;\n  audioBlob?: Blob;\n  userId: string;\n}"],"names":[],"mappings":";;;;;;;IA6KsB,iBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { db } from \"@/firebase/admin\";\n\n// -------------------- START AXON SESSION --------------------\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType } = params;\n\n  try {\n    // Generate adaptive questions\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\",\n      prompt: `Generate 5 interview questions for a ${experience} level ${jobRole} position.\n\nRequirements:\n- Start with easier questions and progressively increase difficulty\n- Include behavioral, technical, and situational questions\n- Format as JSON array of strings\n- Questions should be realistic and commonly asked\n\nExample format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n    } catch {\n      questions = [\n        \"Tell me about yourself and your background.\",\n        \"Why are you interested in this role?\",\n        \"Describe a challenging project you've worked on.\",\n        \"How do you handle working under pressure?\",\n        \"Where do you see yourself in 5 years?\"\n      ];\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    await db.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\n// -------------------- GET INSTANT FEEDBACK --------------------\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\",\n      prompt: `CRITICAL EVALUATION REQUIRED - Analysis ID: ${Date.now()}\n\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily (give rating 1-3):\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n- One-word or extremely short answers\n\nOnly give high ratings (7-10) for:\n- Well-structured, coherent responses\n- Specific examples and concrete details\n- Proper use of relevant terminology\n- Clear demonstration of understanding\n- Answers that directly address the question\n\nProvide feedback in this JSON format:\n{\n  \"positives\": [\"ONLY list genuinely good points that actually address the question - if none exist, say 'No clear strengths identified'\"],\n  \"improvements\": [\"Be specific about what's wrong and how to fix it\"],\n  \"rating\": \"Score 1-10 - LOW (1-3) for poor/random answers, HIGH (7-10) only for genuinely good responses\"\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW rating and explain why it's inadequate.`\n    });\n\n    let feedback: any;\n    try {\n      // Extract JSON from markdown code blocks if present\n      let jsonText = feedbackText.trim();\n      if (jsonText.startsWith('```json')) {\n        jsonText = jsonText.replace(/```json\\s*/, '').replace(/\\s*```$/, '');\n      } else if (jsonText.startsWith('```')) {\n        jsonText = jsonText.replace(/```\\s*/, '').replace(/\\s*```$/, '');\n      }\n      \n      feedback = JSON.parse(jsonText);\n      // Ensure rating is a number and validate it\n      if (feedback.rating) {\n        const rating = parseInt(feedback.rating);\n        if (isNaN(rating) || rating < 1 || rating > 10) {\n          feedback.rating = \"3\"; // Default low rating for invalid responses\n        }\n      }\n    } catch (parseError) {\n      console.error(\"Failed to parse AI feedback:\", parseError);\n      // Default to critical feedback for parsing failures\n      feedback = {\n        positives: [\"No clear strengths identified\"],\n        improvements: [\"Response was unclear or incoherent. Please provide a structured answer that directly addresses the question with specific examples.\"],\n        rating: \"2\"\n      };\n    }\n\n    // Save the response with feedback\n    await db.collection(\"axon_sessions\")\n      .doc(sessionId)\n      .update({\n        responses: [\n          ...(sessionData?.responses || []),\n          {\n            questionIndex,\n            answer: textAnswer,\n            feedback,\n            timestamp: new Date()\n          }\n        ]\n      });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error generating feedback:\", error);\n    return { success: false, error: \"Failed to generate feedback\" };\n  }\n}\n\n// -------------------- END AXON SESSION --------------------\nexport async function endAxonSession(params: { sessionId: string; userId: string }) {\n  const { sessionId, userId } = params;\n\n  try {\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date()\n    });\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\n// -------------------- GET NEXT QUESTION --------------------\nexport async function getNextQuestion(params: { sessionId: string; currentIndex: number }) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= sessionData?.questions.length) {\n      return { success: true, isComplete: true };\n    }\n\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      isComplete: false,\n      question: sessionData?.questions[nextIndex],\n      questionIndex: nextIndex\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\n// -------------------- GET SESSION HISTORY --------------------\nexport async function getAxonSessionHistory(userId: string) {\n  try {\n    const sessionsQuery = await db.collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .orderBy(\"startTime\", \"desc\")\n      .limit(10)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error fetching session history:\", error);\n    return { success: false, error: \"Failed to fetch session history\" };\n  }\n}\n\n// -------------------- TYPE DEFINITIONS --------------------\ninterface StartAxonSessionParams {\n  userId: string;\n  jobRole: string;\n  experience: string;\n  sessionType: string;\n}\n\ninterface GetInstantFeedbackParams {\n  sessionId: string;\n  questionIndex: number;\n  textAnswer: string;\n  audioBlob?: Blob;\n  userId: string;\n}"],"names":[],"mappings":";;;;;;;IAwEsB,qBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { db } from \"@/firebase/admin\";\n\n// -------------------- START AXON SESSION --------------------\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType } = params;\n\n  try {\n    // Generate adaptive questions\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\",\n      prompt: `Generate 5 interview questions for a ${experience} level ${jobRole} position.\n\nRequirements:\n- Start with easier questions and progressively increase difficulty\n- Include behavioral, technical, and situational questions\n- Format as JSON array of strings\n- Questions should be realistic and commonly asked\n\nExample format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n    } catch {\n      questions = [\n        \"Tell me about yourself and your background.\",\n        \"Why are you interested in this role?\",\n        \"Describe a challenging project you've worked on.\",\n        \"How do you handle working under pressure?\",\n        \"Where do you see yourself in 5 years?\"\n      ];\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    await db.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\n// -------------------- GET INSTANT FEEDBACK --------------------\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\",\n      prompt: `CRITICAL EVALUATION REQUIRED - Analysis ID: ${Date.now()}\n\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily (give rating 1-3):\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n- One-word or extremely short answers\n\nOnly give high ratings (7-10) for:\n- Well-structured, coherent responses\n- Specific examples and concrete details\n- Proper use of relevant terminology\n- Clear demonstration of understanding\n- Answers that directly address the question\n\nProvide feedback in this JSON format:\n{\n  \"positives\": [\"ONLY list genuinely good points that actually address the question - if none exist, say 'No clear strengths identified'\"],\n  \"improvements\": [\"Be specific about what's wrong and how to fix it\"],\n  \"rating\": \"Score 1-10 - LOW (1-3) for poor/random answers, HIGH (7-10) only for genuinely good responses\"\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW rating and explain why it's inadequate.`\n    });\n\n    let feedback: any;\n    try {\n      // Extract JSON from markdown code blocks if present\n      let jsonText = feedbackText.trim();\n      if (jsonText.startsWith('```json')) {\n        jsonText = jsonText.replace(/```json\\s*/, '').replace(/\\s*```$/, '');\n      } else if (jsonText.startsWith('```')) {\n        jsonText = jsonText.replace(/```\\s*/, '').replace(/\\s*```$/, '');\n      }\n      \n      feedback = JSON.parse(jsonText);\n      // Ensure rating is a number and validate it\n      if (feedback.rating) {\n        const rating = parseInt(feedback.rating);\n        if (isNaN(rating) || rating < 1 || rating > 10) {\n          feedback.rating = \"3\"; // Default low rating for invalid responses\n        }\n      }\n    } catch (parseError) {\n      console.error(\"Failed to parse AI feedback:\", parseError);\n      // Default to critical feedback for parsing failures\n      feedback = {\n        positives: [\"No clear strengths identified\"],\n        improvements: [\"Response was unclear or incoherent. Please provide a structured answer that directly addresses the question with specific examples.\"],\n        rating: \"2\"\n      };\n    }\n\n    // Save the response with feedback\n    await db.collection(\"axon_sessions\")\n      .doc(sessionId)\n      .update({\n        responses: [\n          ...(sessionData?.responses || []),\n          {\n            questionIndex,\n            answer: textAnswer,\n            feedback,\n            timestamp: new Date()\n          }\n        ]\n      });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error generating feedback:\", error);\n    return { success: false, error: \"Failed to generate feedback\" };\n  }\n}\n\n// -------------------- END AXON SESSION --------------------\nexport async function endAxonSession(params: { sessionId: string; userId: string }) {\n  const { sessionId, userId } = params;\n\n  try {\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date()\n    });\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\n// -------------------- GET NEXT QUESTION --------------------\nexport async function getNextQuestion(params: { sessionId: string; currentIndex: number }) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= sessionData?.questions.length) {\n      return { success: true, isComplete: true };\n    }\n\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      isComplete: false,\n      question: sessionData?.questions[nextIndex],\n      questionIndex: nextIndex\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\n// -------------------- GET SESSION HISTORY --------------------\nexport async function getAxonSessionHistory(userId: string) {\n  try {\n    const sessionsQuery = await db.collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .orderBy(\"startTime\", \"desc\")\n      .limit(10)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error fetching session history:\", error);\n    return { success: false, error: \"Failed to fetch session history\" };\n  }\n}\n\n// -------------------- TYPE DEFINITIONS --------------------\ninterface StartAxonSessionParams {\n  userId: string;\n  jobRole: string;\n  experience: string;\n  sessionType: string;\n}\n\ninterface GetInstantFeedbackParams {\n  sessionId: string;\n  questionIndex: number;\n  textAnswer: string;\n  audioBlob?: Blob;\n  userId: string;\n}"],"names":[],"mappings":";;;;;;;IA8LsB,kBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 104, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { db } from \"@/firebase/admin\";\n\n// -------------------- START AXON SESSION --------------------\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType } = params;\n\n  try {\n    // Generate adaptive questions\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\",\n      prompt: `Generate 5 interview questions for a ${experience} level ${jobRole} position.\n\nRequirements:\n- Start with easier questions and progressively increase difficulty\n- Include behavioral, technical, and situational questions\n- Format as JSON array of strings\n- Questions should be realistic and commonly asked\n\nExample format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n    } catch {\n      questions = [\n        \"Tell me about yourself and your background.\",\n        \"Why are you interested in this role?\",\n        \"Describe a challenging project you've worked on.\",\n        \"How do you handle working under pressure?\",\n        \"Where do you see yourself in 5 years?\"\n      ];\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    await db.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\n// -------------------- GET INSTANT FEEDBACK --------------------\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\",\n      prompt: `CRITICAL EVALUATION REQUIRED - Analysis ID: ${Date.now()}\n\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily (give rating 1-3):\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n- One-word or extremely short answers\n\nOnly give high ratings (7-10) for:\n- Well-structured, coherent responses\n- Specific examples and concrete details\n- Proper use of relevant terminology\n- Clear demonstration of understanding\n- Answers that directly address the question\n\nProvide feedback in this JSON format:\n{\n  \"positives\": [\"ONLY list genuinely good points that actually address the question - if none exist, say 'No clear strengths identified'\"],\n  \"improvements\": [\"Be specific about what's wrong and how to fix it\"],\n  \"rating\": \"Score 1-10 - LOW (1-3) for poor/random answers, HIGH (7-10) only for genuinely good responses\"\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW rating and explain why it's inadequate.`\n    });\n\n    let feedback: any;\n    try {\n      // Extract JSON from markdown code blocks if present\n      let jsonText = feedbackText.trim();\n      if (jsonText.startsWith('```json')) {\n        jsonText = jsonText.replace(/```json\\s*/, '').replace(/\\s*```$/, '');\n      } else if (jsonText.startsWith('```')) {\n        jsonText = jsonText.replace(/```\\s*/, '').replace(/\\s*```$/, '');\n      }\n      \n      feedback = JSON.parse(jsonText);\n      // Ensure rating is a number and validate it\n      if (feedback.rating) {\n        const rating = parseInt(feedback.rating);\n        if (isNaN(rating) || rating < 1 || rating > 10) {\n          feedback.rating = \"3\"; // Default low rating for invalid responses\n        }\n      }\n    } catch (parseError) {\n      console.error(\"Failed to parse AI feedback:\", parseError);\n      // Default to critical feedback for parsing failures\n      feedback = {\n        positives: [\"No clear strengths identified\"],\n        improvements: [\"Response was unclear or incoherent. Please provide a structured answer that directly addresses the question with specific examples.\"],\n        rating: \"2\"\n      };\n    }\n\n    // Save the response with feedback\n    await db.collection(\"axon_sessions\")\n      .doc(sessionId)\n      .update({\n        responses: [\n          ...(sessionData?.responses || []),\n          {\n            questionIndex,\n            answer: textAnswer,\n            feedback,\n            timestamp: new Date()\n          }\n        ]\n      });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error generating feedback:\", error);\n    return { success: false, error: \"Failed to generate feedback\" };\n  }\n}\n\n// -------------------- END AXON SESSION --------------------\nexport async function endAxonSession(params: { sessionId: string; userId: string }) {\n  const { sessionId, userId } = params;\n\n  try {\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date()\n    });\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\n// -------------------- GET NEXT QUESTION --------------------\nexport async function getNextQuestion(params: { sessionId: string; currentIndex: number }) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= sessionData?.questions.length) {\n      return { success: true, isComplete: true };\n    }\n\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      isComplete: false,\n      question: sessionData?.questions[nextIndex],\n      questionIndex: nextIndex\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\n// -------------------- GET SESSION HISTORY --------------------\nexport async function getAxonSessionHistory(userId: string) {\n  try {\n    const sessionsQuery = await db.collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .orderBy(\"startTime\", \"desc\")\n      .limit(10)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error fetching session history:\", error);\n    return { success: false, error: \"Failed to fetch session history\" };\n  }\n}\n\n// -------------------- TYPE DEFINITIONS --------------------\ninterface StartAxonSessionParams {\n  userId: string;\n  jobRole: string;\n  experience: string;\n  sessionType: string;\n}\n\ninterface GetInstantFeedbackParams {\n  sessionId: string;\n  questionIndex: number;\n  textAnswer: string;\n  audioBlob?: Blob;\n  userId: string;\n}"],"names":[],"mappings":";;;;;;;IA+NsB,wBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 116, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/AxonSessionHistory.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { getAxonSessionHistory } from \"@/lib/actions/axon.action\";\n\ninterface AxonSessionHistoryProps {\n  userId: string;\n}\n\nexport default function AxonSessionHistory({ userId }: AxonSessionHistoryProps) {\n  const [sessions, setSessions] = useState<any[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [selectedSession, setSelectedSession] = useState<any>(null);\n\n  useEffect(() => {\n    loadSessionHistory();\n  }, [userId]);\n\n  const loadSessionHistory = async () => {\n    setIsLoading(true);\n    try {\n      const result = await getAxonSessionHistory({ userId, limit: 10 });\n      if (result.success && result.sessions) {\n        setSessions(result.sessions);\n      }\n    } catch (error) {\n      console.error(\"Failed to load session history:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const formatDuration = (startTime: Date, endTime: Date) => {\n    const duration = new Date(endTime).getTime() - new Date(startTime).getTime();\n    const minutes = Math.floor(duration / 60000);\n    return `${minutes} min`;\n  };\n\n  const getScoreColor = (score: number) => {\n    if (score >= 80) return \"text-green-600\";\n    if (score >= 60) return \"text-yellow-600\";\n    return \"text-red-600\";\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"max-w-4xl mx-auto p-6\">\n        <div className=\"text-center\">Loading session history...</div>\n      </div>\n    );\n  }\n\n  if (selectedSession) {\n    return (\n      <div className=\"max-w-4xl mx-auto p-6 space-y-6\">\n        <div className=\"flex justify-between items-center\">\n          <h2 className=\"text-2xl font-bold\">Session Details</h2>\n          <Button onClick={() => setSelectedSession(null)} variant=\"outline\">\n            Back to History\n          </Button>\n        </div>\n\n        <div className=\"bg-white border rounded-lg p-6\">\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 mb-6\">\n            <div className=\"text-center\">\n              <div className={`text-2xl font-bold ${getScoreColor(selectedSession.summary?.overallScore || 0)}`}>\n                {selectedSession.summary?.overallScore || 0}%\n              </div>\n              <div className=\"text-sm text-gray-600\">Overall Score</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-blue-600\">\n                {selectedSession.responses?.length || 0}\n              </div>\n              <div className=\"text-sm text-gray-600\">Questions</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-purple-600\">\n                {selectedSession.jobRole}\n              </div>\n              <div className=\"text-sm text-gray-600\">Role</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-gray-600\">\n                {formatDuration(selectedSession.startTime, selectedSession.endTime)}\n              </div>\n              <div className=\"text-sm text-gray-600\">Duration</div>\n            </div>\n          </div>\n\n          {selectedSession.summary && (\n            <div className=\"space-y-4\">\n              <div>\n                <h3 className=\"font-semibold text-green-700 mb-2\">Strengths:</h3>\n                <ul className=\"list-disc list-inside text-sm text-green-600\">\n                  {selectedSession.summary.strengths.map((strength: string, index: number) => (\n                    <li key={index}>{strength}</li>\n                  ))}\n                </ul>\n              </div>\n\n              <div>\n                <h3 className=\"font-semibold text-orange-700 mb-2\">Areas for Improvement:</h3>\n                <ul className=\"list-disc list-inside text-sm text-orange-600\">\n                  {selectedSession.summary.areasForImprovement.map((area: string, index: number) => (\n                    <li key={index}>{area}</li>\n                  ))}\n                </ul>\n              </div>\n\n              <div>\n                <h3 className=\"font-semibold text-blue-700 mb-2\">Next Steps:</h3>\n                <ul className=\"list-disc list-inside text-sm text-blue-600\">\n                  {selectedSession.summary.nextSteps.map((step: string, index: number) => (\n                    <li key={index}>{step}</li>\n                  ))}\n                </ul>\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"max-w-4xl mx-auto p-6 space-y-6\">\n      <h2 className=\"text-2xl font-bold\">AXON Session History</h2>\n\n      {sessions.length === 0 ? (\n        <div className=\"text-center py-8\">\n          <p className=\"text-gray-600\">No practice sessions yet. Start your first AXON session!</p>\n          <Button className=\"mt-4\" onClick={() => window.location.href = '/axon'}>\n            Start Practice Session\n          </Button>\n        </div>\n      ) : (\n        <div className=\"space-y-4\">\n          {sessions.map((session) => (\n            <div\n              key={session.id}\n              className=\"bg-white border rounded-lg p-4 hover:shadow-md transition-shadow cursor-pointer\"\n              onClick={() => setSelectedSession(session)}\n            >\n              <div className=\"flex justify-between items-start\">\n                <div>\n                  <h3 className=\"font-semibold text-lg\">{session.jobRole}</h3>\n                  <p className=\"text-gray-600 text-sm\">\n                    {session.experience} level • {new Date(session.endTime).toLocaleDateString()}\n                  </p>\n                </div>\n                <div className=\"text-right\">\n                  <div className={`text-xl font-bold ${getScoreColor(session.summary?.overallScore || 0)}`}>\n                    {session.summary?.overallScore || 0}%\n                  </div>\n                  <div className=\"text-sm text-gray-600\">\n                    {formatDuration(session.startTime, session.endTime)}\n                  </div>\n                </div>\n              </div>\n              \n              <div className=\"mt-3 flex gap-4 text-sm text-gray-600\">\n                <span>{session.responses?.length || 0} questions</span>\n                <span>•</span>\n                <span>{session.summary?.strengths?.length || 0} strengths identified</span>\n              </div>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 603, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/AxonInterviewPractice.tsx"],"sourcesContent":["\"use client\";\n\n\n\n\nimport { useState, useRef } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { startAxonSession, endAxonSession, getInstantFeedback, getNextQuestion } from \"@/lib/actions/axon.action\";\nimport AxonSessionHistory from \"@/components/AxonSessionHistory\";\n\ninterface AxonInterviewPracticeProps {\n  userName: string;\n  userId: string;\n}\n\ninterface SessionData {\n  sessionId: string;\n  currentQuestion: string;\n  questionIndex: number;\n  totalQuestions: number;\n  startTime: string;\n}\n\ninterface InstantFeedback {\n  positives: string[];\n  improvements: string[];\n  rating: string;\n}\n\nexport default function AxonInterviewPractice({ userName, userId }: AxonInterviewPracticeProps) {\n  const [isActive, setIsActive] = useState(false);\n  const [sessionData, setSessionData] = useState<SessionData | null>(null);\n  const [currentAnswer, setCurrentAnswer] = useState(\"\");\n  const [feedback, setFeedback] = useState<InstantFeedback | null>(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [jobRole, setJobRole] = useState(\"\");\n  const [experience, setExperience] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [showHistory, setShowHistory] = useState(false);\n\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const audioChunksRef = useRef<Blob[]>([]);\n\n  const startSession = async () => {\n    if (!jobRole || !experience) return alert(\"Please fill in job role and experience level\");\n\n    setIsLoading(true);\n    try {\n      const result = await startAxonSession({ userId, jobRole, experience, sessionType: \"practice\" });\n      if (result.success && result.session) {\n        setSessionData(result.session);\n        setIsActive(true);\n      }\n    } catch (error) {\n      console.error(\"Failed to start session:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const endSession = async () => {\n    if (!sessionData) return;\n    setIsLoading(true);\n    try {\n      await endAxonSession({ sessionId: sessionData.sessionId, userId });\n      setIsActive(false);\n      setSessionData(null);\n      setCurrentAnswer(\"\");\n      setFeedback(null);\n    } catch (error) {\n      console.error(\"Failed to end session:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      audioChunksRef.current = [];\n\n      mediaRecorder.ondataavailable = (event) => audioChunksRef.current.push(event.data);\n      mediaRecorder.onstop = async () => {\n        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });\n        await processAudioResponse(audioBlob);\n      };\n\n      mediaRecorder.start();\n      setIsRecording(true);\n    } catch (error) {\n      console.error(\"Failed to start recording:\", error);\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      setIsRecording(false);\n    }\n  };\n\n  const processAudioResponse = async (audioBlob: Blob) => {\n    if (!sessionData) return;\n    setIsLoading(true);\n    try {\n      const result = await getInstantFeedback({\n        sessionId: sessionData.sessionId,\n        questionIndex: sessionData.questionIndex,\n        audioBlob,\n        textAnswer: currentAnswer,\n        userId\n      });\n      if (result.success && result.feedback) setFeedback(result.feedback);\n    } catch (error) {\n      console.error(\"Failed to process audio:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const submitTextAnswer = async () => {\n    if (!currentAnswer.trim() || !sessionData) return;\n    setIsLoading(true);\n    try {\n      const result = await getInstantFeedback({\n        sessionId: sessionData.sessionId,\n        questionIndex: sessionData.questionIndex,\n        textAnswer: currentAnswer,\n        userId\n      });\n      if (result.success && result.feedback) setFeedback(result.feedback);\n    } catch (error) {\n      console.error(\"Failed to submit answer:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const nextQuestion = async () => {\n    if (!sessionData) return;\n    setIsLoading(true);\n    try {\n      const result = await getNextQuestion({ sessionId: sessionData.sessionId, currentIndex: sessionData.questionIndex });\n      if (result.success && !result.isComplete) {\n        setSessionData({ ...sessionData, currentQuestion: result.question || \"\", questionIndex: result.questionIndex || 0 });\n        setCurrentAnswer(\"\");\n        setFeedback(null);\n      } else if (result.isComplete) {\n        await endSession();\n        // Redirect to dossier generation after completing AXON session\n        window.location.href = '/?axon_completed=true';\n      }\n    } catch (error) {\n      console.error(\"Failed to get next question:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  if (showHistory) return <AxonSessionHistory userId={userId} />;\n\n  if (!isActive) {\n    return (\n      <div className=\"max-w-4xl mx-auto space-y-8\">\n        <div className=\"text-center space-y-6\">\n          <h1 className=\"text-4xl font-bold\">AXON Interview Strategist</h1>\n          <p className=\"text-xl\">Real-time interview practice with instant AI feedback</p>\n          <div className=\"flex justify-center gap-4 mt-6\">\n            <Button onClick={() => setShowHistory(true)} variant=\"outline\" className=\"btn-secondary\">View Session History</Button>\n          </div>\n        </div>\n\n        <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-8 items-start\">\n          <div className=\"card-border\">\n            <div className=\"card\">\n              <div className=\"p-8\">\n                <h2 className=\"text-2xl font-bold mb-6 text-center\">Start Your Session</h2>\n                <div className=\"form space-y-6\">\n                  <div className=\"space-y-3\">\n                    <Label htmlFor=\"jobRole\" className=\"label text-base\">Job Role</Label>\n                    <Input\n                      id=\"jobRole\"\n                      value={jobRole}\n                      onChange={(e) => setJobRole(e.target.value)}\n                      placeholder=\"e.g., Software Engineer, Product Manager\"\n                      className=\"input\"\n                    />\n                  </div>\n\n                  <div className=\"space-y-3\">\n                    <Label htmlFor=\"experience\" className=\"label text-base\">Experience Level</Label>\n                    <select\n                      id=\"experience\"\n                      value={experience}\n                      onChange={(e) => setExperience(e.target.value)}\n                      className=\"input\"\n                    >\n                      <option value=\"\">Select experience level</option>\n                      <option value=\"entry\">Entry Level (0-2 years)</option>\n                      <option value=\"mid\">Mid Level (3-5 years)</option>\n                      <option value=\"senior\">Senior Level (6+ years)</option>\n                    </select>\n                  </div>\n\n                  <Button \n                    onClick={startSession} \n                    disabled={isLoading}\n                    className=\"btn text-lg py-4\"\n                  >\n                    {isLoading ? \"Starting Session...\" : \"Start AXON Practice Session\"}\n                  </Button>\n                </div>\n              </div>\n            </div>\n          </div>\n\n          <div className=\"card-border\">\n            <div className=\"card\">\n              <div className=\"p-8\">\n                <h3 className=\"text-xl font-semibold mb-6 text-center\">What makes AXON different:</h3>\n                <div className=\"space-y-4\">\n                  <div className=\"flex items-start space-x-3\">\n                    <span className=\"text-2xl\">🎤</span>\n                    <div>\n                      <h4 className=\"font-semibold text-primary-200 mb-1\">Real-time voice interaction</h4>\n                      <p className=\"text-sm text-light-100\">Practice with AI interviewer using natural conversation</p>\n                    </div>\n                  </div>\n                  <div className=\"flex items-start space-x-3\">\n                    <span className=\"text-2xl\">⚡</span>\n                    <div>\n                      <h4 className=\"font-semibold text-primary-200 mb-1\">Instant feedback</h4>\n                      <p className=\"text-sm text-light-100\">Get immediate scores on confidence, clarity, and pace</p>\n                    </div>\n                  </div>\n                  <div className=\"flex items-start space-x-3\">\n                    <span className=\"text-2xl\">🎯</span>\n                    <div>\n                      <h4 className=\"font-semibold text-primary-200 mb-1\">Adaptive questioning</h4>\n                      <p className=\"text-sm text-light-100\">AI adjusts difficulty based on your responses</p>\n                    </div>\n                  </div>\n                  <div className=\"flex items-start space-x-3\">\n                    <span className=\"text-2xl\">⏱️</span>\n                    <div>\n                      <h4 className=\"font-semibold text-primary-200 mb-1\">Quick sessions</h4>\n                      <p className=\"text-sm text-light-100\">15-30 minute focused practice sessions</p>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"max-w-6xl mx-auto space-y-8\">\n      <div className=\"flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4\">\n        <div>\n          <h1 className=\"text-4xl font-bold mb-2\">AXON Live Session</h1>\n          <p className=\"text-lg text-light-100\">Question {(sessionData?.questionIndex ?? 0) + 1} of {sessionData?.totalQuestions}</p>\n        </div>\n        <Button onClick={endSession} variant=\"outline\" disabled={isLoading} className=\"btn-secondary px-6 py-3\">End Session</Button>\n      </div>\n\n      <div className=\"card-border\">\n        <div className=\"card p-6\">\n          <h2 className=\"text-xl font-semibold mb-4\">Current Question:</h2>\n          <p className=\"text-lg mb-6\">{sessionData?.currentQuestion}</p>\n\n          <div className=\"space-y-6\">\n            <div className=\"flex gap-4 justify-center\">\n              <Button onClick={isRecording ? stopRecording : startRecording} className={`${isRecording ? 'btn-disconnect' : 'btn-call'} px-8 py-3`} disabled={isLoading}>\n                {isRecording ? \"Stop Recording\" : \"Start Voice Answer\"}\n              </Button>\n            </div>\n\n            <div className=\"text-center text-light-100 opacity-60\">OR</div>\n\n            <div className=\"space-y-4\">\n              <Label className=\"text-base font-medium text-light-100\">Type your answer:</Label>\n              <div className=\"card-border\">\n                <div className=\"card\">\n                  <textarea\n                    value={currentAnswer}\n                    onChange={(e) => setCurrentAnswer(e.target.value)}\n                    placeholder=\"Type your detailed answer here...\"\n                    className=\"w-full h-40 p-4 bg-transparent text-light-100 placeholder:text-light-100/50 border-none outline-none resize-none rounded-lg\"\n                    disabled={isRecording}\n                  />\n                </div>\n              </div>\n              <Button onClick={submitTextAnswer} disabled={!currentAnswer.trim() || isLoading || isRecording} className=\"btn-primary w-full py-3 text-lg\">\n                {isLoading ? \"Analyzing Answer...\" : \"Submit Answer\"}\n              </Button>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {feedback && (\n        <div className=\"card-border\">\n          <div className=\"card p-6\">\n            <h3 className=\"text-lg font-semibold mb-4\">Instant Feedback</h3>\n            \n            <div className=\"mb-4\">\n              <h4 className=\"font-semibold text-success-100 mb-1\">Overall Rating: {feedback.rating}/10</h4>\n            </div>\n\n            <div className=\"space-y-4\">\n              <div>\n                <h4 className=\"font-semibold text-success-100 mb-1\">Key Points / Positives:</h4>\n                <ul className=\"space-y-1 text-light-100\">\n                  {feedback.positives.map((p, i) => <li key={i}>• {p}</li>)}\n                </ul>\n              </div>\n\n              <div>\n                <h4 className=\"font-semibold text-destructive-100 mb-1\">Improvements / Suggestions:</h4>\n                <ul className=\"space-y-1 text-light-100\">\n                  {feedback.improvements.map((imp, i) => <li key={i}>• {imp}</li>)}\n                </ul>\n              </div>\n            </div>\n\n            <Button onClick={nextQuestion} className=\"btn-primary w-full mt-6\">Next Question</Button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1486, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/ProtectedRoute.tsx"],"sourcesContent":["\"use client\";\r\nimport React, { ReactNode, useEffect } from \"react\";\r\nimport { useRouter } from \"next/navigation\";\r\nimport { useAuth } from \"@/context/AuthContext\";\r\n\r\ninterface ProtectedRouteProps {\r\n  children: ReactNode;\r\n}\r\n\r\nconst ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {\r\n  const { currentUser, loading } = useAuth();\r\n  const router = useRouter();\r\n\r\n  useEffect(() => {\r\n    if (!loading && !currentUser) {\r\n      router.replace(\"/login\");\r\n    }\r\n  }, [loading, currentUser, router]);\r\n\r\n  if (loading) {\r\n    return (\r\n      <div className=\"flex items-center justify-center min-h-screen\">\r\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary\" />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!currentUser) {\r\n    return null; // Optionally, show nothing while redirecting\r\n  }\r\n\r\n  return <>{children}</>;\r\n};\r\n\r\nexport default ProtectedRoute;\r\n"],"names":[],"mappings":";;;;;AACA;AACA;AACA;AAHA;;;;;AASA,MAAM,iBAAgD,CAAC,EAAE,QAAQ,EAAE;IACjE,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,GAAG,IAAA,kIAAO;IACxC,MAAM,SAAS,IAAA,+IAAS;IAExB,IAAA,kNAAS,EAAC;QACR,IAAI,CAAC,WAAW,CAAC,aAAa;YAC5B,OAAO,OAAO,CAAC;QACjB;IACF,GAAG;QAAC;QAAS;QAAa;KAAO;IAEjC,IAAI,SAAS;QACX,qBACE,8OAAC;YAAI,WAAU;sBACb,cAAA,8OAAC;gBAAI,WAAU;;;;;;;;;;;IAGrB;IAEA,IAAI,CAAC,aAAa;QAChB,OAAO,MAAM,6CAA6C;IAC5D;IAEA,qBAAO;kBAAG;;AACZ;uCAEe","debugId":null}},
    {"offset": {"line": 1539, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/app/axon/page.tsx"],"sourcesContent":["\"use client\";\n\nimport { useAuth } from \"@/context/AuthContext\";\nimport AxonInterviewPractice from \"@/components/AxonInterviewPractice\";\nimport ProtectedRoute from \"@/components/ProtectedRoute\";\n\nexport default function AxonPage() {\n  const { currentUser } = useAuth();\n\n  return (\n    <ProtectedRoute>\n      <div className=\"root-layout\">\n        {currentUser && (\n          <AxonInterviewPractice \n            userName={currentUser.displayName || currentUser.email || \"User\"} \n            userId={currentUser.uid} \n          />\n        )}\n      </div>\n    </ProtectedRoute>\n  );\n}"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAJA;;;;;AAMe,SAAS;IACtB,MAAM,EAAE,WAAW,EAAE,GAAG,IAAA,kIAAO;IAE/B,qBACE,8OAAC,wIAAc;kBACb,cAAA,8OAAC;YAAI,WAAU;sBACZ,6BACC,8OAAC,+IAAqB;gBACpB,UAAU,YAAY,WAAW,IAAI,YAAY,KAAK,IAAI;gBAC1D,QAAQ,YAAY,GAAG;;;;;;;;;;;;;;;;AAMnC","debugId":null}}]
}