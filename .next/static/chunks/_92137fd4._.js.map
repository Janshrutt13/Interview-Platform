{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        \"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        \"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]\",\n        \"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Input }\n"],"names":[],"mappings":";;;;;AAEA;;;AAEA,SAAS,MAAM,KAA4D;QAA5D,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAsC,GAA5D;IACb,qBACE,6LAAC;QACC,MAAM;QACN,aAAU;QACV,WAAW,IAAA,qHAAE,EACX,8bACA,iFACA,0GACA;QAED,GAAG,KAAK;;;;;;AAGf;KAdS","debugId":null}},
    {"offset": {"line": 36, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Label({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  return (\n    <LabelPrimitive.Root\n      data-slot=\"label\"\n      className={cn(\n        \"flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Label }\n"],"names":[],"mappings":";;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,MAAM,KAGoC;QAHpC,EACb,SAAS,EACT,GAAG,OAC8C,GAHpC;IAIb,qBACE,6LAAC,4KAAmB;QAClB,aAAU;QACV,WAAW,IAAA,qHAAE,EACX,uNACA;QAED,GAAG,KAAK;;;;;;AAGf;KAdS","debugId":null}},
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { db } from \"@/firebase/admin\";\n\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType } = params;\n\n  try {\n    // Generate adaptive questions based on role and experience\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `Generate 5 interview questions for a ${experience} level ${jobRole} position. \n      \n      Requirements:\n      - Start with easier questions and progressively increase difficulty\n      - Include behavioral, technical, and situational questions\n      - Format as JSON array of strings\n      - Questions should be realistic and commonly asked\n      \n      Example format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`,\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\"\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n    } catch {\n      // Fallback questions if JSON parsing fails\n      questions = [\n        \"Tell me about yourself and your background.\",\n        \"Why are you interested in this role?\",\n        \"Describe a challenging project you've worked on.\",\n        \"How do you handle working under pressure?\",\n        \"Where do you see yourself in 5 years?\"\n      ];\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    // Store session in Firestore\n    await db.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob, userId } = params;\n\n  try {\n    // Get session data\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    // Analyze the response using AI\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `CRITICAL EVALUATION REQUIRED:\n\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily:\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n\nProvide feedback in this JSON format:\n{\n  \"confidence\": [score 1-100 - LOW if answer is incoherent/random],\n  \"clarity\": [score 1-100 - LOW if answer doesn't make sense],\n  \"pace\": [score 1-100 - LOW if answer is incomplete/rushed],\n  \"keyPoints\": [\"ONLY list genuinely relevant points that actually address the question\"],\n  \"suggestions\": [\"Be specific about what's wrong and how to fix it\"]\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW scores (20-40) and explain why it's inadequate.\nOnly give high scores for genuinely good, coherent answers that properly address the question.`,\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\"\n    });\n\n    let feedback;\n    try {\n      feedback = JSON.parse(feedbackText);\n    } catch {\n      // Fallback feedback\n      feedback = {\n        confidence: 75,\n        clarity: 80,\n        pace: 70,\n        keyPoints: [\"Good structure\", \"Relevant examples\"],\n        suggestions: [\"Add more specific details\", \"Practice speaking more confidently\"]\n      };\n    }\n\n    // Store the response and feedback\n    const responseData = {\n      questionIndex,\n      question: currentQuestion,\n      answer: textAnswer,\n      feedback,\n      timestamp: new Date(),\n      hasAudio: !!audioBlob\n    };\n\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      [`responses.${questionIndex}`]: responseData\n    });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error getting instant feedback:\", error);\n    return { success: false, error: \"Failed to analyze response\" };\n  }\n}\n\nexport async function getNextQuestion(params: GetNextQuestionParams) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const questions = sessionData?.questions || [];\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= questions.length) {\n      return { success: false, error: \"No more questions\", isComplete: true };\n    }\n\n    // Update session with new question index\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      question: questions[nextIndex],\n      questionIndex: nextIndex,\n      isComplete: false\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\nexport async function endAxonSession(params: EndAxonSessionParams) {\n  const { sessionId, userId } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const responses = sessionData?.responses || [];\n\n    // Generate session summary\n    const { text: summaryText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `Generate a session summary based on these interview responses:\n\n${JSON.stringify(responses, null, 2)}\n\nProvide a summary in this JSON format:\n{\n  \"overallScore\": [average score 1-100],\n  \"strengths\": [\"strength1\", \"strength2\", \"strength3\"],\n  \"areasForImprovement\": [\"area1\", \"area2\"],\n  \"keyInsights\": [\"insight1\", \"insight2\"],\n  \"nextSteps\": [\"step1\", \"step2\"]\n}`,\n      system: \"You are an expert interview coach providing comprehensive session analysis.\"\n    });\n\n    let summary;\n    try {\n      summary = JSON.parse(summaryText);\n    } catch {\n      summary = {\n        overallScore: 75,\n        strengths: [\"Good communication\", \"Relevant examples\"],\n        areasForImprovement: [\"More confidence\", \"Better structure\"],\n        keyInsights: [\"Shows potential\", \"Needs practice\"],\n        nextSteps: [\"Practice more\", \"Work on confidence\"]\n      };\n    }\n\n    // Update session with summary and end time\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date(),\n      summary\n    });\n\n    return { success: true, summary };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\nexport async function getAxonSessionHistory(params: GetAxonSessionHistoryParams) {\n  const { userId, limit = 10 } = params;\n\n  try {\n    const sessionsQuery = await db\n      .collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .where(\"status\", \"==\", \"completed\")\n      .orderBy(\"endTime\", \"desc\")\n      .limit(limit)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error getting session history:\", error);\n    return { success: false, error: \"Failed to get session history\" };\n  }\n}"],"names":[],"mappings":";;;;;;;IAMsB,mBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 85, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { db } from \"@/firebase/admin\";\n\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType } = params;\n\n  try {\n    // Generate adaptive questions based on role and experience\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `Generate 5 interview questions for a ${experience} level ${jobRole} position. \n      \n      Requirements:\n      - Start with easier questions and progressively increase difficulty\n      - Include behavioral, technical, and situational questions\n      - Format as JSON array of strings\n      - Questions should be realistic and commonly asked\n      \n      Example format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`,\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\"\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n    } catch {\n      // Fallback questions if JSON parsing fails\n      questions = [\n        \"Tell me about yourself and your background.\",\n        \"Why are you interested in this role?\",\n        \"Describe a challenging project you've worked on.\",\n        \"How do you handle working under pressure?\",\n        \"Where do you see yourself in 5 years?\"\n      ];\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    // Store session in Firestore\n    await db.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob, userId } = params;\n\n  try {\n    // Get session data\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    // Analyze the response using AI\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `CRITICAL EVALUATION REQUIRED:\n\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily:\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n\nProvide feedback in this JSON format:\n{\n  \"confidence\": [score 1-100 - LOW if answer is incoherent/random],\n  \"clarity\": [score 1-100 - LOW if answer doesn't make sense],\n  \"pace\": [score 1-100 - LOW if answer is incomplete/rushed],\n  \"keyPoints\": [\"ONLY list genuinely relevant points that actually address the question\"],\n  \"suggestions\": [\"Be specific about what's wrong and how to fix it\"]\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW scores (20-40) and explain why it's inadequate.\nOnly give high scores for genuinely good, coherent answers that properly address the question.`,\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\"\n    });\n\n    let feedback;\n    try {\n      feedback = JSON.parse(feedbackText);\n    } catch {\n      // Fallback feedback\n      feedback = {\n        confidence: 75,\n        clarity: 80,\n        pace: 70,\n        keyPoints: [\"Good structure\", \"Relevant examples\"],\n        suggestions: [\"Add more specific details\", \"Practice speaking more confidently\"]\n      };\n    }\n\n    // Store the response and feedback\n    const responseData = {\n      questionIndex,\n      question: currentQuestion,\n      answer: textAnswer,\n      feedback,\n      timestamp: new Date(),\n      hasAudio: !!audioBlob\n    };\n\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      [`responses.${questionIndex}`]: responseData\n    });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error getting instant feedback:\", error);\n    return { success: false, error: \"Failed to analyze response\" };\n  }\n}\n\nexport async function getNextQuestion(params: GetNextQuestionParams) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const questions = sessionData?.questions || [];\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= questions.length) {\n      return { success: false, error: \"No more questions\", isComplete: true };\n    }\n\n    // Update session with new question index\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      question: questions[nextIndex],\n      questionIndex: nextIndex,\n      isComplete: false\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\nexport async function endAxonSession(params: EndAxonSessionParams) {\n  const { sessionId, userId } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const responses = sessionData?.responses || [];\n\n    // Generate session summary\n    const { text: summaryText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `Generate a session summary based on these interview responses:\n\n${JSON.stringify(responses, null, 2)}\n\nProvide a summary in this JSON format:\n{\n  \"overallScore\": [average score 1-100],\n  \"strengths\": [\"strength1\", \"strength2\", \"strength3\"],\n  \"areasForImprovement\": [\"area1\", \"area2\"],\n  \"keyInsights\": [\"insight1\", \"insight2\"],\n  \"nextSteps\": [\"step1\", \"step2\"]\n}`,\n      system: \"You are an expert interview coach providing comprehensive session analysis.\"\n    });\n\n    let summary;\n    try {\n      summary = JSON.parse(summaryText);\n    } catch {\n      summary = {\n        overallScore: 75,\n        strengths: [\"Good communication\", \"Relevant examples\"],\n        areasForImprovement: [\"More confidence\", \"Better structure\"],\n        keyInsights: [\"Shows potential\", \"Needs practice\"],\n        nextSteps: [\"Practice more\", \"Work on confidence\"]\n      };\n    }\n\n    // Update session with summary and end time\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date(),\n      summary\n    });\n\n    return { success: true, summary };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\nexport async function getAxonSessionHistory(params: GetAxonSessionHistoryParams) {\n  const { userId, limit = 10 } = params;\n\n  try {\n    const sessionsQuery = await db\n      .collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .where(\"status\", \"==\", \"completed\")\n      .orderBy(\"endTime\", \"desc\")\n      .limit(limit)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error getting session history:\", error);\n    return { success: false, error: \"Failed to get session history\" };\n  }\n}"],"names":[],"mappings":";;;;;;;IA4LsB,iBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { db } from \"@/firebase/admin\";\n\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType } = params;\n\n  try {\n    // Generate adaptive questions based on role and experience\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `Generate 5 interview questions for a ${experience} level ${jobRole} position. \n      \n      Requirements:\n      - Start with easier questions and progressively increase difficulty\n      - Include behavioral, technical, and situational questions\n      - Format as JSON array of strings\n      - Questions should be realistic and commonly asked\n      \n      Example format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`,\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\"\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n    } catch {\n      // Fallback questions if JSON parsing fails\n      questions = [\n        \"Tell me about yourself and your background.\",\n        \"Why are you interested in this role?\",\n        \"Describe a challenging project you've worked on.\",\n        \"How do you handle working under pressure?\",\n        \"Where do you see yourself in 5 years?\"\n      ];\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    // Store session in Firestore\n    await db.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob, userId } = params;\n\n  try {\n    // Get session data\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    // Analyze the response using AI\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `CRITICAL EVALUATION REQUIRED:\n\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily:\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n\nProvide feedback in this JSON format:\n{\n  \"confidence\": [score 1-100 - LOW if answer is incoherent/random],\n  \"clarity\": [score 1-100 - LOW if answer doesn't make sense],\n  \"pace\": [score 1-100 - LOW if answer is incomplete/rushed],\n  \"keyPoints\": [\"ONLY list genuinely relevant points that actually address the question\"],\n  \"suggestions\": [\"Be specific about what's wrong and how to fix it\"]\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW scores (20-40) and explain why it's inadequate.\nOnly give high scores for genuinely good, coherent answers that properly address the question.`,\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\"\n    });\n\n    let feedback;\n    try {\n      feedback = JSON.parse(feedbackText);\n    } catch {\n      // Fallback feedback\n      feedback = {\n        confidence: 75,\n        clarity: 80,\n        pace: 70,\n        keyPoints: [\"Good structure\", \"Relevant examples\"],\n        suggestions: [\"Add more specific details\", \"Practice speaking more confidently\"]\n      };\n    }\n\n    // Store the response and feedback\n    const responseData = {\n      questionIndex,\n      question: currentQuestion,\n      answer: textAnswer,\n      feedback,\n      timestamp: new Date(),\n      hasAudio: !!audioBlob\n    };\n\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      [`responses.${questionIndex}`]: responseData\n    });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error getting instant feedback:\", error);\n    return { success: false, error: \"Failed to analyze response\" };\n  }\n}\n\nexport async function getNextQuestion(params: GetNextQuestionParams) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const questions = sessionData?.questions || [];\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= questions.length) {\n      return { success: false, error: \"No more questions\", isComplete: true };\n    }\n\n    // Update session with new question index\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      question: questions[nextIndex],\n      questionIndex: nextIndex,\n      isComplete: false\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\nexport async function endAxonSession(params: EndAxonSessionParams) {\n  const { sessionId, userId } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const responses = sessionData?.responses || [];\n\n    // Generate session summary\n    const { text: summaryText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `Generate a session summary based on these interview responses:\n\n${JSON.stringify(responses, null, 2)}\n\nProvide a summary in this JSON format:\n{\n  \"overallScore\": [average score 1-100],\n  \"strengths\": [\"strength1\", \"strength2\", \"strength3\"],\n  \"areasForImprovement\": [\"area1\", \"area2\"],\n  \"keyInsights\": [\"insight1\", \"insight2\"],\n  \"nextSteps\": [\"step1\", \"step2\"]\n}`,\n      system: \"You are an expert interview coach providing comprehensive session analysis.\"\n    });\n\n    let summary;\n    try {\n      summary = JSON.parse(summaryText);\n    } catch {\n      summary = {\n        overallScore: 75,\n        strengths: [\"Good communication\", \"Relevant examples\"],\n        areasForImprovement: [\"More confidence\", \"Better structure\"],\n        keyInsights: [\"Shows potential\", \"Needs practice\"],\n        nextSteps: [\"Practice more\", \"Work on confidence\"]\n      };\n    }\n\n    // Update session with summary and end time\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date(),\n      summary\n    });\n\n    return { success: true, summary };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\nexport async function getAxonSessionHistory(params: GetAxonSessionHistoryParams) {\n  const { userId, limit = 10 } = params;\n\n  try {\n    const sessionsQuery = await db\n      .collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .where(\"status\", \"==\", \"completed\")\n      .orderBy(\"endTime\", \"desc\")\n      .limit(limit)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error getting session history:\", error);\n    return { success: false, error: \"Failed to get session history\" };\n  }\n}"],"names":[],"mappings":";;;;;;;IAwEsB,qBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { db } from \"@/firebase/admin\";\n\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType } = params;\n\n  try {\n    // Generate adaptive questions based on role and experience\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `Generate 5 interview questions for a ${experience} level ${jobRole} position. \n      \n      Requirements:\n      - Start with easier questions and progressively increase difficulty\n      - Include behavioral, technical, and situational questions\n      - Format as JSON array of strings\n      - Questions should be realistic and commonly asked\n      \n      Example format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`,\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\"\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n    } catch {\n      // Fallback questions if JSON parsing fails\n      questions = [\n        \"Tell me about yourself and your background.\",\n        \"Why are you interested in this role?\",\n        \"Describe a challenging project you've worked on.\",\n        \"How do you handle working under pressure?\",\n        \"Where do you see yourself in 5 years?\"\n      ];\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    // Store session in Firestore\n    await db.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob, userId } = params;\n\n  try {\n    // Get session data\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    // Analyze the response using AI\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `CRITICAL EVALUATION REQUIRED:\n\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily:\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n\nProvide feedback in this JSON format:\n{\n  \"confidence\": [score 1-100 - LOW if answer is incoherent/random],\n  \"clarity\": [score 1-100 - LOW if answer doesn't make sense],\n  \"pace\": [score 1-100 - LOW if answer is incomplete/rushed],\n  \"keyPoints\": [\"ONLY list genuinely relevant points that actually address the question\"],\n  \"suggestions\": [\"Be specific about what's wrong and how to fix it\"]\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW scores (20-40) and explain why it's inadequate.\nOnly give high scores for genuinely good, coherent answers that properly address the question.`,\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\"\n    });\n\n    let feedback;\n    try {\n      feedback = JSON.parse(feedbackText);\n    } catch {\n      // Fallback feedback\n      feedback = {\n        confidence: 75,\n        clarity: 80,\n        pace: 70,\n        keyPoints: [\"Good structure\", \"Relevant examples\"],\n        suggestions: [\"Add more specific details\", \"Practice speaking more confidently\"]\n      };\n    }\n\n    // Store the response and feedback\n    const responseData = {\n      questionIndex,\n      question: currentQuestion,\n      answer: textAnswer,\n      feedback,\n      timestamp: new Date(),\n      hasAudio: !!audioBlob\n    };\n\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      [`responses.${questionIndex}`]: responseData\n    });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error getting instant feedback:\", error);\n    return { success: false, error: \"Failed to analyze response\" };\n  }\n}\n\nexport async function getNextQuestion(params: GetNextQuestionParams) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const questions = sessionData?.questions || [];\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= questions.length) {\n      return { success: false, error: \"No more questions\", isComplete: true };\n    }\n\n    // Update session with new question index\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      question: questions[nextIndex],\n      questionIndex: nextIndex,\n      isComplete: false\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\nexport async function endAxonSession(params: EndAxonSessionParams) {\n  const { sessionId, userId } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const responses = sessionData?.responses || [];\n\n    // Generate session summary\n    const { text: summaryText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `Generate a session summary based on these interview responses:\n\n${JSON.stringify(responses, null, 2)}\n\nProvide a summary in this JSON format:\n{\n  \"overallScore\": [average score 1-100],\n  \"strengths\": [\"strength1\", \"strength2\", \"strength3\"],\n  \"areasForImprovement\": [\"area1\", \"area2\"],\n  \"keyInsights\": [\"insight1\", \"insight2\"],\n  \"nextSteps\": [\"step1\", \"step2\"]\n}`,\n      system: \"You are an expert interview coach providing comprehensive session analysis.\"\n    });\n\n    let summary;\n    try {\n      summary = JSON.parse(summaryText);\n    } catch {\n      summary = {\n        overallScore: 75,\n        strengths: [\"Good communication\", \"Relevant examples\"],\n        areasForImprovement: [\"More confidence\", \"Better structure\"],\n        keyInsights: [\"Shows potential\", \"Needs practice\"],\n        nextSteps: [\"Practice more\", \"Work on confidence\"]\n      };\n    }\n\n    // Update session with summary and end time\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date(),\n      summary\n    });\n\n    return { success: true, summary };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\nexport async function getAxonSessionHistory(params: GetAxonSessionHistoryParams) {\n  const { userId, limit = 10 } = params;\n\n  try {\n    const sessionsQuery = await db\n      .collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .where(\"status\", \"==\", \"completed\")\n      .orderBy(\"endTime\", \"desc\")\n      .limit(limit)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error getting session history:\", error);\n    return { success: false, error: \"Failed to get session history\" };\n  }\n}"],"names":[],"mappings":";;;;;;;IA0JsB,kBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { db } from \"@/firebase/admin\";\n\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType } = params;\n\n  try {\n    // Generate adaptive questions based on role and experience\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `Generate 5 interview questions for a ${experience} level ${jobRole} position. \n      \n      Requirements:\n      - Start with easier questions and progressively increase difficulty\n      - Include behavioral, technical, and situational questions\n      - Format as JSON array of strings\n      - Questions should be realistic and commonly asked\n      \n      Example format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`,\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\"\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n    } catch {\n      // Fallback questions if JSON parsing fails\n      questions = [\n        \"Tell me about yourself and your background.\",\n        \"Why are you interested in this role?\",\n        \"Describe a challenging project you've worked on.\",\n        \"How do you handle working under pressure?\",\n        \"Where do you see yourself in 5 years?\"\n      ];\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    // Store session in Firestore\n    await db.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob, userId } = params;\n\n  try {\n    // Get session data\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    // Analyze the response using AI\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `CRITICAL EVALUATION REQUIRED:\n\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily:\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n\nProvide feedback in this JSON format:\n{\n  \"confidence\": [score 1-100 - LOW if answer is incoherent/random],\n  \"clarity\": [score 1-100 - LOW if answer doesn't make sense],\n  \"pace\": [score 1-100 - LOW if answer is incomplete/rushed],\n  \"keyPoints\": [\"ONLY list genuinely relevant points that actually address the question\"],\n  \"suggestions\": [\"Be specific about what's wrong and how to fix it\"]\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW scores (20-40) and explain why it's inadequate.\nOnly give high scores for genuinely good, coherent answers that properly address the question.`,\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\"\n    });\n\n    let feedback;\n    try {\n      feedback = JSON.parse(feedbackText);\n    } catch {\n      // Fallback feedback\n      feedback = {\n        confidence: 75,\n        clarity: 80,\n        pace: 70,\n        keyPoints: [\"Good structure\", \"Relevant examples\"],\n        suggestions: [\"Add more specific details\", \"Practice speaking more confidently\"]\n      };\n    }\n\n    // Store the response and feedback\n    const responseData = {\n      questionIndex,\n      question: currentQuestion,\n      answer: textAnswer,\n      feedback,\n      timestamp: new Date(),\n      hasAudio: !!audioBlob\n    };\n\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      [`responses.${questionIndex}`]: responseData\n    });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error getting instant feedback:\", error);\n    return { success: false, error: \"Failed to analyze response\" };\n  }\n}\n\nexport async function getNextQuestion(params: GetNextQuestionParams) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const questions = sessionData?.questions || [];\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= questions.length) {\n      return { success: false, error: \"No more questions\", isComplete: true };\n    }\n\n    // Update session with new question index\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      question: questions[nextIndex],\n      questionIndex: nextIndex,\n      isComplete: false\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\nexport async function endAxonSession(params: EndAxonSessionParams) {\n  const { sessionId, userId } = params;\n\n  try {\n    const sessionDoc = await db.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const responses = sessionData?.responses || [];\n\n    // Generate session summary\n    const { text: summaryText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      prompt: `Generate a session summary based on these interview responses:\n\n${JSON.stringify(responses, null, 2)}\n\nProvide a summary in this JSON format:\n{\n  \"overallScore\": [average score 1-100],\n  \"strengths\": [\"strength1\", \"strength2\", \"strength3\"],\n  \"areasForImprovement\": [\"area1\", \"area2\"],\n  \"keyInsights\": [\"insight1\", \"insight2\"],\n  \"nextSteps\": [\"step1\", \"step2\"]\n}`,\n      system: \"You are an expert interview coach providing comprehensive session analysis.\"\n    });\n\n    let summary;\n    try {\n      summary = JSON.parse(summaryText);\n    } catch {\n      summary = {\n        overallScore: 75,\n        strengths: [\"Good communication\", \"Relevant examples\"],\n        areasForImprovement: [\"More confidence\", \"Better structure\"],\n        keyInsights: [\"Shows potential\", \"Needs practice\"],\n        nextSteps: [\"Practice more\", \"Work on confidence\"]\n      };\n    }\n\n    // Update session with summary and end time\n    await db.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date(),\n      summary\n    });\n\n    return { success: true, summary };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\nexport async function getAxonSessionHistory(params: GetAxonSessionHistoryParams) {\n  const { userId, limit = 10 } = params;\n\n  try {\n    const sessionsQuery = await db\n      .collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .where(\"status\", \"==\", \"completed\")\n      .orderBy(\"endTime\", \"desc\")\n      .limit(limit)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error getting session history:\", error);\n    return { success: false, error: \"Failed to get session history\" };\n  }\n}"],"names":[],"mappings":";;;;;;;IAqPsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 145, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/AxonSessionHistory.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { getAxonSessionHistory } from \"@/lib/actions/axon.action\";\n\ninterface AxonSessionHistoryProps {\n  userId: string;\n}\n\nexport default function AxonSessionHistory({ userId }: AxonSessionHistoryProps) {\n  const [sessions, setSessions] = useState<any[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [selectedSession, setSelectedSession] = useState<any>(null);\n\n  useEffect(() => {\n    loadSessionHistory();\n  }, [userId]);\n\n  const loadSessionHistory = async () => {\n    setIsLoading(true);\n    try {\n      const result = await getAxonSessionHistory({ userId, limit: 10 });\n      if (result.success && result.sessions) {\n        setSessions(result.sessions);\n      }\n    } catch (error) {\n      console.error(\"Failed to load session history:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const formatDuration = (startTime: Date, endTime: Date) => {\n    const duration = new Date(endTime).getTime() - new Date(startTime).getTime();\n    const minutes = Math.floor(duration / 60000);\n    return `${minutes} min`;\n  };\n\n  const getScoreColor = (score: number) => {\n    if (score >= 80) return \"text-green-600\";\n    if (score >= 60) return \"text-yellow-600\";\n    return \"text-red-600\";\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"max-w-4xl mx-auto p-6\">\n        <div className=\"text-center\">Loading session history...</div>\n      </div>\n    );\n  }\n\n  if (selectedSession) {\n    return (\n      <div className=\"max-w-4xl mx-auto p-6 space-y-6\">\n        <div className=\"flex justify-between items-center\">\n          <h2 className=\"text-2xl font-bold\">Session Details</h2>\n          <Button onClick={() => setSelectedSession(null)} variant=\"outline\">\n            Back to History\n          </Button>\n        </div>\n\n        <div className=\"bg-white border rounded-lg p-6\">\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 mb-6\">\n            <div className=\"text-center\">\n              <div className={`text-2xl font-bold ${getScoreColor(selectedSession.summary?.overallScore || 0)}`}>\n                {selectedSession.summary?.overallScore || 0}%\n              </div>\n              <div className=\"text-sm text-gray-600\">Overall Score</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-blue-600\">\n                {selectedSession.responses?.length || 0}\n              </div>\n              <div className=\"text-sm text-gray-600\">Questions</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-purple-600\">\n                {selectedSession.jobRole}\n              </div>\n              <div className=\"text-sm text-gray-600\">Role</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-gray-600\">\n                {formatDuration(selectedSession.startTime, selectedSession.endTime)}\n              </div>\n              <div className=\"text-sm text-gray-600\">Duration</div>\n            </div>\n          </div>\n\n          {selectedSession.summary && (\n            <div className=\"space-y-4\">\n              <div>\n                <h3 className=\"font-semibold text-green-700 mb-2\">Strengths:</h3>\n                <ul className=\"list-disc list-inside text-sm text-green-600\">\n                  {selectedSession.summary.strengths.map((strength: string, index: number) => (\n                    <li key={index}>{strength}</li>\n                  ))}\n                </ul>\n              </div>\n\n              <div>\n                <h3 className=\"font-semibold text-orange-700 mb-2\">Areas for Improvement:</h3>\n                <ul className=\"list-disc list-inside text-sm text-orange-600\">\n                  {selectedSession.summary.areasForImprovement.map((area: string, index: number) => (\n                    <li key={index}>{area}</li>\n                  ))}\n                </ul>\n              </div>\n\n              <div>\n                <h3 className=\"font-semibold text-blue-700 mb-2\">Next Steps:</h3>\n                <ul className=\"list-disc list-inside text-sm text-blue-600\">\n                  {selectedSession.summary.nextSteps.map((step: string, index: number) => (\n                    <li key={index}>{step}</li>\n                  ))}\n                </ul>\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"max-w-4xl mx-auto p-6 space-y-6\">\n      <h2 className=\"text-2xl font-bold\">AXON Session History</h2>\n\n      {sessions.length === 0 ? (\n        <div className=\"text-center py-8\">\n          <p className=\"text-gray-600\">No practice sessions yet. Start your first AXON session!</p>\n          <Button className=\"mt-4\" onClick={() => window.location.href = '/axon'}>\n            Start Practice Session\n          </Button>\n        </div>\n      ) : (\n        <div className=\"space-y-4\">\n          {sessions.map((session) => (\n            <div\n              key={session.id}\n              className=\"bg-white border rounded-lg p-4 hover:shadow-md transition-shadow cursor-pointer\"\n              onClick={() => setSelectedSession(session)}\n            >\n              <div className=\"flex justify-between items-start\">\n                <div>\n                  <h3 className=\"font-semibold text-lg\">{session.jobRole}</h3>\n                  <p className=\"text-gray-600 text-sm\">\n                    {session.experience} level  {new Date(session.endTime).toLocaleDateString()}\n                  </p>\n                </div>\n                <div className=\"text-right\">\n                  <div className={`text-xl font-bold ${getScoreColor(session.summary?.overallScore || 0)}`}>\n                    {session.summary?.overallScore || 0}%\n                  </div>\n                  <div className=\"text-sm text-gray-600\">\n                    {formatDuration(session.startTime, session.endTime)}\n                  </div>\n                </div>\n              </div>\n              \n              <div className=\"mt-3 flex gap-4 text-sm text-gray-600\">\n                <span>{session.responses?.length || 0} questions</span>\n                <span></span>\n                <span>{session.summary?.strengths?.length || 0} strengths identified</span>\n              </div>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 648, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/AxonInterviewPractice.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useRef, useEffect } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { startAxonSession, endAxonSession, getInstantFeedback, getNextQuestion } from \"@/lib/actions/axon.action\";\nimport AxonSessionHistory from \"@/components/AxonSessionHistory\";\n\ninterface AxonInterviewPracticeProps {\n  userName: string;\n  userId: string;\n}\n\ninterface SessionData {\n  sessionId: string;\n  currentQuestion: string;\n  questionIndex: number;\n  totalQuestions: number;\n  startTime: string;\n}\n\ninterface InstantFeedback {\n  confidence: number;\n  clarity: number;\n  pace: number;\n  keyPoints: string[];\n  suggestions: string[];\n}\n\nexport default function AxonInterviewPractice({ userName, userId }: AxonInterviewPracticeProps) {\n  const [isActive, setIsActive] = useState(false);\n  const [sessionData, setSessionData] = useState<SessionData | null>(null);\n  const [currentAnswer, setCurrentAnswer] = useState(\"\");\n  const [feedback, setFeedback] = useState<InstantFeedback | null>(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [jobRole, setJobRole] = useState(\"\");\n  const [experience, setExperience] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [showHistory, setShowHistory] = useState(false);\n\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const audioChunksRef = useRef<Blob[]>([]);\n\n  const startSession = async () => {\n    if (!jobRole || !experience) {\n      alert(\"Please fill in job role and experience level\");\n      return;\n    }\n\n    setIsLoading(true);\n    try {\n      const result = await startAxonSession({\n        userId,\n        jobRole,\n        experience,\n        sessionType: \"practice\"\n      });\n\n      if (result.success && result.session) {\n        setSessionData(result.session);\n        setIsActive(true);\n      }\n    } catch (error) {\n      console.error(\"Failed to start session:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const endSession = async () => {\n    if (!sessionData) return;\n\n    setIsLoading(true);\n    try {\n      await endAxonSession({\n        sessionId: sessionData.sessionId,\n        userId\n      });\n      \n      setIsActive(false);\n      setSessionData(null);\n      setCurrentAnswer(\"\");\n      setFeedback(null);\n    } catch (error) {\n      console.error(\"Failed to end session:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      const mediaRecorder = new MediaRecorder(stream);\n      \n      mediaRecorderRef.current = mediaRecorder;\n      audioChunksRef.current = [];\n\n      mediaRecorder.ondataavailable = (event) => {\n        audioChunksRef.current.push(event.data);\n      };\n\n      mediaRecorder.onstop = async () => {\n        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });\n        await processAudioResponse(audioBlob);\n      };\n\n      mediaRecorder.start();\n      setIsRecording(true);\n    } catch (error) {\n      console.error(\"Failed to start recording:\", error);\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      setIsRecording(false);\n    }\n  };\n\n  const processAudioResponse = async (audioBlob: Blob) => {\n    if (!sessionData) return;\n\n    setIsLoading(true);\n    try {\n      const result = await getInstantFeedback({\n        sessionId: sessionData.sessionId,\n        questionIndex: sessionData.questionIndex,\n        audioBlob,\n        textAnswer: currentAnswer,\n        userId\n      });\n\n      if (result.success && result.feedback) {\n        setFeedback(result.feedback);\n      }\n    } catch (error) {\n      console.error(\"Failed to process audio:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const submitTextAnswer = async () => {\n    if (!currentAnswer.trim() || !sessionData) return;\n\n    setIsLoading(true);\n    try {\n      const result = await getInstantFeedback({\n        sessionId: sessionData.sessionId,\n        questionIndex: sessionData.questionIndex,\n        textAnswer: currentAnswer,\n        userId\n      });\n\n      if (result.success && result.feedback) {\n        setFeedback(result.feedback);\n      }\n    } catch (error) {\n      console.error(\"Failed to submit answer:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const nextQuestion = async () => {\n    if (!sessionData) return;\n    \n    setIsLoading(true);\n    try {\n      const result = await getNextQuestion({\n        sessionId: sessionData.sessionId,\n        currentIndex: sessionData.questionIndex\n      });\n\n      if (result.success && !result.isComplete) {\n        setSessionData({\n          ...sessionData,\n          currentQuestion: result.question || \"\",\n          questionIndex: result.questionIndex || 0\n        });\n        setCurrentAnswer(\"\");\n        setFeedback(null);\n      } else if (result.isComplete) {\n        // Session completed, end it\n        await endSession();\n      }\n    } catch (error) {\n      console.error(\"Failed to get next question:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  if (showHistory) {\n    return <AxonSessionHistory userId={userId} />;\n  }\n\n  if (!isActive) {\n    return (\n      <div className=\"max-w-4xl mx-auto space-y-8\">\n        <div className=\"text-center space-y-6\">\n          <h1 className=\"text-4xl font-bold\">AXON Interview Strategist</h1>\n          <p className=\"text-xl\">Real-time interview practice with instant AI feedback</p>\n          <div className=\"flex justify-center gap-4 mt-6\">\n            <Button onClick={() => setShowHistory(true)} variant=\"outline\" className=\"btn-secondary\">\n              View Session History\n            </Button>\n          </div>\n        </div>\n\n        <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-8 items-start\">\n          <div className=\"card-border\">\n            <div className=\"card\">\n              <div className=\"p-8\">\n                <h2 className=\"text-2xl font-bold mb-6 text-center\">Start Your Session</h2>\n                <div className=\"form space-y-6\">\n                  <div className=\"space-y-3\">\n                    <Label htmlFor=\"jobRole\" className=\"label text-base\">Job Role</Label>\n                    <Input\n                      id=\"jobRole\"\n                      value={jobRole}\n                      onChange={(e) => setJobRole(e.target.value)}\n                      placeholder=\"e.g., Software Engineer, Product Manager\"\n                      className=\"input\"\n                    />\n                  </div>\n\n                  <div className=\"space-y-3\">\n                    <Label htmlFor=\"experience\" className=\"label text-base\">Experience Level</Label>\n                    <select\n                      id=\"experience\"\n                      value={experience}\n                      onChange={(e) => setExperience(e.target.value)}\n                      className=\"input\"\n                    >\n                      <option value=\"\">Select experience level</option>\n                      <option value=\"entry\">Entry Level (0-2 years)</option>\n                      <option value=\"mid\">Mid Level (3-5 years)</option>\n                      <option value=\"senior\">Senior Level (6+ years)</option>\n                    </select>\n                  </div>\n\n                  <Button \n                    onClick={startSession} \n                    disabled={isLoading}\n                    className=\"btn text-lg py-4\"\n                  >\n                    {isLoading ? \"Starting Session...\" : \"Start AXON Practice Session\"}\n                  </Button>\n                </div>\n              </div>\n            </div>\n          </div>\n\n          <div className=\"card-border\">\n            <div className=\"card\">\n              <div className=\"p-8\">\n                <h3 className=\"text-xl font-semibold mb-6 text-center\">What makes AXON different:</h3>\n                <div className=\"space-y-4\">\n                  <div className=\"flex items-start space-x-3\">\n                    <span className=\"text-2xl\"></span>\n                    <div>\n                      <h4 className=\"font-semibold text-primary-200 mb-1\">Real-time voice interaction</h4>\n                      <p className=\"text-sm text-light-100\">Practice with AI interviewer using natural conversation</p>\n                    </div>\n                  </div>\n                  <div className=\"flex items-start space-x-3\">\n                    <span className=\"text-2xl\"></span>\n                    <div>\n                      <h4 className=\"font-semibold text-primary-200 mb-1\">Instant feedback</h4>\n                      <p className=\"text-sm text-light-100\">Get immediate scores on confidence, clarity, and pace</p>\n                    </div>\n                  </div>\n                  <div className=\"flex items-start space-x-3\">\n                    <span className=\"text-2xl\"></span>\n                    <div>\n                      <h4 className=\"font-semibold text-primary-200 mb-1\">Adaptive questioning</h4>\n                      <p className=\"text-sm text-light-100\">AI adjusts difficulty based on your responses</p>\n                    </div>\n                  </div>\n                  <div className=\"flex items-start space-x-3\">\n                    <span className=\"text-2xl\"></span>\n                    <div>\n                      <h4 className=\"font-semibold text-primary-200 mb-1\">Quick sessions</h4>\n                      <p className=\"text-sm text-light-100\">15-30 minute focused practice sessions</p>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n\n\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"max-w-6xl mx-auto space-y-8\">\n      <div className=\"flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4\">\n        <div className=\"text-center sm:text-left\">\n          <h1 className=\"text-4xl font-bold mb-2\">AXON Live Session</h1>\n          <p className=\"text-lg text-light-100\">\n            Question {sessionData?.questionIndex + 1} of {sessionData?.totalQuestions}\n          </p>\n        </div>\n        <Button onClick={endSession} variant=\"outline\" disabled={isLoading} className=\"btn-secondary px-6 py-3\">\n          End Session\n        </Button>\n      </div>\n\n      <div className=\"card-border\">\n        <div className=\"card\">\n          <div className=\"p-6\">\n            <h2 className=\"text-xl font-semibold mb-4\">Current Question:</h2>\n            <p className=\"text-lg mb-6\">{sessionData?.currentQuestion}</p>\n\n            <div className=\"space-y-6\">\n              <div className=\"flex gap-4 justify-center\">\n                <Button\n                  onClick={isRecording ? stopRecording : startRecording}\n                  className={`${isRecording ? 'btn-disconnect' : 'btn-call'} px-8 py-3`}\n                  disabled={isLoading}\n                >\n                  {isRecording ? \"Stop Recording\" : \"Start Voice Answer\"}\n                </Button>\n                \n                {isRecording && (\n                  <div className=\"flex items-center text-destructive-100\">\n                    <div className=\"w-3 h-3 bg-destructive-100 rounded-full animate-pulse mr-2\"></div>\n                    <span className=\"text-light-100\">Recording...</span>\n                  </div>\n                )}\n              </div>\n\n              <div className=\"text-center text-light-100 opacity-60\">\n                <span>OR</span>\n              </div>\n\n              <div className=\"space-y-4\">\n                <Label className=\"text-base font-medium text-light-100\">Type your answer:</Label>\n                <div className=\"card-border\">\n                  <div className=\"card\">\n                    <textarea\n                      value={currentAnswer}\n                      onChange={(e) => setCurrentAnswer(e.target.value)}\n                      placeholder=\"Type your detailed answer here...\"\n                      className=\"w-full h-40 p-4 bg-transparent text-light-100 placeholder:text-light-100/50 border-none outline-none resize-none rounded-lg\"\n                      disabled={isRecording}\n                    />\n                  </div>\n                </div>\n                <Button \n                  onClick={submitTextAnswer}\n                  disabled={!currentAnswer.trim() || isLoading || isRecording}\n                  className=\"btn-primary w-full py-3 text-lg\"\n                >\n                  {isLoading ? \"Analyzing Answer...\" : \"Submit Answer\"}\n                </Button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {feedback && (\n        <div className=\"card-border\">\n          <div className=\"card\">\n            <div className=\"p-6\">\n              <h3 className=\"text-lg font-semibold mb-4\">Instant Feedback</h3>\n              \n              <div className=\"grid grid-cols-3 gap-4 mb-6\">\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold text-success-100\">{feedback.confidence}%</div>\n                  <div className=\"text-sm text-light-100\">Confidence</div>\n                </div>\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold text-primary-200\">{feedback.clarity}%</div>\n                  <div className=\"text-sm text-light-100\">Clarity</div>\n                </div>\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold text-light-400\">{feedback.pace}%</div>\n                  <div className=\"text-sm text-light-100\">Pace</div>\n                </div>\n              </div>\n\n              <div className=\"space-y-4\">\n                <div>\n                  <h4 className=\"font-semibold text-success-100 mb-2\">Key Points Covered:</h4>\n                  <ul className=\"space-y-1 text-light-100\">\n                    {feedback.keyPoints.map((point, index) => (\n                      <li key={index}> {point}</li>\n                    ))}\n                  </ul>\n                </div>\n\n                <div>\n                  <h4 className=\"font-semibold text-destructive-100 mb-2\">Suggestions:</h4>\n                  <ul className=\"space-y-1 text-light-100\">\n                    {feedback.suggestions.map((suggestion, index) => (\n                      <li key={index}> {suggestion}</li>\n                    ))}\n                  </ul>\n                </div>\n              </div>\n\n              <Button onClick={nextQuestion} className=\"btn-primary w-full mt-6\">\n                Next Question\n              </Button>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1672, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/ProtectedRoute.tsx"],"sourcesContent":["\"use client\";\r\nimport React, { ReactNode, useEffect } from \"react\";\r\nimport { useRouter } from \"next/navigation\";\r\nimport { useAuth } from \"@/context/AuthContext\";\r\n\r\ninterface ProtectedRouteProps {\r\n  children: ReactNode;\r\n}\r\n\r\nconst ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {\r\n  const { currentUser, loading } = useAuth();\r\n  const router = useRouter();\r\n\r\n  useEffect(() => {\r\n    if (!loading && !currentUser) {\r\n      router.replace(\"/login\");\r\n    }\r\n  }, [loading, currentUser, router]);\r\n\r\n  if (loading) {\r\n    return (\r\n      <div className=\"flex items-center justify-center min-h-screen\">\r\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary\" />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!currentUser) {\r\n    return null; // Optionally, show nothing while redirecting\r\n  }\r\n\r\n  return <>{children}</>;\r\n};\r\n\r\nexport default ProtectedRoute;\r\n"],"names":[],"mappings":";;;;;AACA;AACA;AACA;;;AAHA;;;;AASA,MAAM,iBAAgD;QAAC,EAAE,QAAQ,EAAE;;IACjE,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,GAAG,IAAA,qIAAO;IACxC,MAAM,SAAS,IAAA,kJAAS;IAExB,IAAA,0KAAS;oCAAC;YACR,IAAI,CAAC,WAAW,CAAC,aAAa;gBAC5B,OAAO,OAAO,CAAC;YACjB;QACF;mCAAG;QAAC;QAAS;QAAa;KAAO;IAEjC,IAAI,SAAS;QACX,qBACE,6LAAC;YAAI,WAAU;sBACb,cAAA,6LAAC;gBAAI,WAAU;;;;;;;;;;;IAGrB;IAEA,IAAI,CAAC,aAAa;QAChB,OAAO,MAAM,6CAA6C;IAC5D;IAEA,qBAAO;kBAAG;;AACZ;GAvBM;;QAC6B,qIAAO;QACzB,kJAAS;;;KAFpB;uCAyBS","debugId":null}},
    {"offset": {"line": 1742, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/app/axon/page.tsx"],"sourcesContent":["\"use client\";\n\nimport { useAuth } from \"@/context/AuthContext\";\nimport AxonInterviewPractice from \"@/components/AxonInterviewPractice\";\nimport ProtectedRoute from \"@/components/ProtectedRoute\";\n\nexport default function AxonPage() {\n  const { currentUser } = useAuth();\n\n  return (\n    <ProtectedRoute>\n      <div className=\"root-layout\">\n        {currentUser && (\n          <AxonInterviewPractice \n            userName={currentUser.displayName || currentUser.email || \"User\"} \n            userId={currentUser.uid} \n          />\n        )}\n      </div>\n    </ProtectedRoute>\n  );\n}"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;;;AAJA;;;;AAMe,SAAS;;IACtB,MAAM,EAAE,WAAW,EAAE,GAAG,IAAA,qIAAO;IAE/B,qBACE,6LAAC,2IAAc;kBACb,cAAA,6LAAC;YAAI,WAAU;sBACZ,6BACC,6LAAC,kJAAqB;gBACpB,UAAU,YAAY,WAAW,IAAI,YAAY,KAAK,IAAI;gBAC1D,QAAQ,YAAY,GAAG;;;;;;;;;;;;;;;;AAMnC;GAfwB;;QACE,qIAAO;;;KADT","debugId":null}}]
}