{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/ui/input.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Input({ className, type, ...props }: React.ComponentProps<\"input\">) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        \"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        \"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]\",\n        \"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Input }\n"],"names":[],"mappings":";;;;;AAEA;;;AAEA,SAAS,MAAM,KAA4D;QAA5D,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAsC,GAA5D;IACb,qBACE,6LAAC;QACC,MAAM;QACN,aAAU;QACV,WAAW,IAAA,qHAAE,EACX,8bACA,iFACA,0GACA;QAED,GAAG,KAAK;;;;;;AAGf;KAdS","debugId":null}},
    {"offset": {"line": 36, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Label({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  return (\n    <LabelPrimitive.Root\n      data-slot=\"label\"\n      className={cn(\n        \"flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Label }\n"],"names":[],"mappings":";;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,MAAM,KAGoC;QAHpC,EACb,SAAS,EACT,GAAG,OAC8C,GAHpC;IAIb,qBACE,6LAAC,4KAAmB;QAClB,aAAU;QACV,WAAW,IAAA,qHAAE,EACX,uNACA;QAED,GAAG,KAAK;;;;;;AAGf;KAdS","debugId":null}},
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { adminDb } from \"@/firebase/admin\";\n\n// -------------------- START AXON SESSION --------------------\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType, questionType = 'mixed', numberOfQuestions = 5 } = params;\n\n  try {\n    // Generate adaptive questions based on type\n    const questionTypePrompt = questionType === 'behavioral' \n      ? 'Focus only on behavioral questions using STAR method scenarios'\n      : questionType === 'technical'\n      ? 'Focus only on technical questions related to the role and required skills'\n      : 'Include a balanced mix of behavioral, technical, and situational questions';\n\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\",\n      prompt: `Generate ${numberOfQuestions} interview questions for a ${experience} level ${jobRole} position.\n\nQuestion Type: ${questionType}\nRequirements:\n- ${questionTypePrompt}\n- Start with easier questions and progressively increase difficulty\n- Format as JSON array of strings\n- Questions should be realistic and commonly asked\n\nExample format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n      if (!Array.isArray(questions) || questions.length === 0) {\n        throw new Error('Invalid questions format');\n      }\n    } catch {\n      // Retry AI generation with simpler prompt if parsing fails\n      const { text: retryText } = await generateText({\n        model: google(\"gemini-2.0-flash-001\"),\n        system: \"Generate interview questions as a simple JSON array of strings.\",\n        prompt: `Create ${numberOfQuestions} ${questionType} interview questions for ${jobRole} (${experience} level). Return only a JSON array like: [\"Question 1\", \"Question 2\"]`\n      });\n      \n      try {\n        questions = JSON.parse(retryText);\n      } catch {\n        return { success: false, error: \"Failed to generate questions. Please try again.\" };\n      }\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\n// -------------------- GET INSTANT FEEDBACK --------------------\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\",\n      prompt: `CRITICAL EVALUATION REQUIRED - Analysis ID: ${Date.now()}\n\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily (give rating 1-3):\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n- One-word or extremely short answers\n\nOnly give high ratings (7-10) for:\n- Well-structured, coherent responses\n- Specific examples and concrete details\n- Proper use of relevant terminology\n- Clear demonstration of understanding\n- Answers that directly address the question\n\nProvide feedback in this JSON format:\n{\n  \"positives\": [\"ONLY list genuinely good points that actually address the question - if none exist, say 'No clear strengths identified'\"],\n  \"improvements\": [\"Be specific about what's wrong and how to fix it\"],\n  \"rating\": \"Score 1-10 - LOW (1-3) for poor/random answers, HIGH (7-10) only for genuinely good responses\"\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW rating and explain why it's inadequate.`\n    });\n\n    let feedback: any;\n    try {\n      // Extract JSON from markdown code blocks if present\n      let jsonText = feedbackText.trim();\n      if (jsonText.startsWith('```json')) {\n        jsonText = jsonText.replace(/```json\\s*/, '').replace(/\\s*```$/, '');\n      } else if (jsonText.startsWith('```')) {\n        jsonText = jsonText.replace(/```\\s*/, '').replace(/\\s*```$/, '');\n      }\n      \n      feedback = JSON.parse(jsonText);\n      // Ensure rating is a number and validate it\n      if (feedback.rating) {\n        const rating = parseInt(feedback.rating);\n        if (isNaN(rating) || rating < 1 || rating > 10) {\n          feedback.rating = \"3\"; // Default low rating for invalid responses\n        }\n      }\n    } catch (parseError) {\n      console.error(\"Failed to parse AI feedback:\", parseError);\n      // Default to critical feedback for parsing failures\n      feedback = {\n        positives: [\"No clear strengths identified\"],\n        improvements: [\"Response was unclear or incoherent. Please provide a structured answer that directly addresses the question with specific examples.\"],\n        rating: \"2\"\n      };\n    }\n\n    // Save the response with feedback\n    await adminDb.collection(\"axon_sessions\")\n      .doc(sessionId)\n      .update({\n        responses: [\n          ...(sessionData?.responses || []),\n          {\n            questionIndex,\n            answer: textAnswer,\n            feedback,\n            timestamp: new Date()\n          }\n        ]\n      });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error generating feedback:\", error);\n    return { success: false, error: \"Failed to generate feedback\" };\n  }\n}\n\n\nexport async function endAxonSession(params: { sessionId: string; userId: string }) {\n  const { sessionId, userId } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    \n    // Generate session summary\n    const { text: summaryText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an interview coach providing a session summary.\",\n      prompt: `Summarize this AXON interview practice session:\n\nJob Role: ${sessionData?.jobRole}\nExperience Level: ${sessionData?.experience}\nTotal Questions: ${sessionData?.questions?.length || 0}\nTotal Responses: ${sessionData?.responses?.length || 0}\n\nResponses:\n${sessionData?.responses?.map((r: any, i: number) => \n  `Q${i + 1}: ${sessionData.questions[r.questionIndex]}\\nA: ${r.answer}\\nRating: ${r.feedback?.rating}/10`\n).join('\\n\\n') || 'No responses recorded'}\n\nProvide a brief summary of:\n1. Overall performance\n2. Key strengths observed\n3. Areas for improvement\n4. Recommendation for next steps`\n    });\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date(),\n      summary: summaryText\n    });\n\n    return { success: true, summary: summaryText };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\n\nexport async function getNextQuestion(params: { sessionId: string; currentIndex: number }) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= sessionData?.questions.length) {\n      return { success: true, isComplete: true };\n    }\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      isComplete: false,\n      question: sessionData?.questions[nextIndex],\n      questionIndex: nextIndex\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\n\nexport async function getAxonSessionHistory(userId: string) {\n  try {\n    const sessionsQuery = await adminDb.collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .orderBy(\"startTime\", \"desc\")\n      .limit(10)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error fetching session history:\", error);\n    return { success: false, error: \"Failed to fetch session history\" };\n  }\n}\n\n\ninterface StartAxonSessionParams {\n  userId: string;\n  jobRole: string;\n  experience: string;\n  sessionType: string;\n  questionType?: string;\n  numberOfQuestions?: number;\n}\n\ninterface GetInstantFeedbackParams {\n  sessionId: string;\n  questionIndex: number;\n  textAnswer: string;\n  audioBlob?: Blob;\n  userId: string;\n}"],"names":[],"mappings":";;;;;;;IAOsB,mBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 85, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { adminDb } from \"@/firebase/admin\";\n\n// -------------------- START AXON SESSION --------------------\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType, questionType = 'mixed', numberOfQuestions = 5 } = params;\n\n  try {\n    // Generate adaptive questions based on type\n    const questionTypePrompt = questionType === 'behavioral' \n      ? 'Focus only on behavioral questions using STAR method scenarios'\n      : questionType === 'technical'\n      ? 'Focus only on technical questions related to the role and required skills'\n      : 'Include a balanced mix of behavioral, technical, and situational questions';\n\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\",\n      prompt: `Generate ${numberOfQuestions} interview questions for a ${experience} level ${jobRole} position.\n\nQuestion Type: ${questionType}\nRequirements:\n- ${questionTypePrompt}\n- Start with easier questions and progressively increase difficulty\n- Format as JSON array of strings\n- Questions should be realistic and commonly asked\n\nExample format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n      if (!Array.isArray(questions) || questions.length === 0) {\n        throw new Error('Invalid questions format');\n      }\n    } catch {\n      // Retry AI generation with simpler prompt if parsing fails\n      const { text: retryText } = await generateText({\n        model: google(\"gemini-2.0-flash-001\"),\n        system: \"Generate interview questions as a simple JSON array of strings.\",\n        prompt: `Create ${numberOfQuestions} ${questionType} interview questions for ${jobRole} (${experience} level). Return only a JSON array like: [\"Question 1\", \"Question 2\"]`\n      });\n      \n      try {\n        questions = JSON.parse(retryText);\n      } catch {\n        return { success: false, error: \"Failed to generate questions. Please try again.\" };\n      }\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\n// -------------------- GET INSTANT FEEDBACK --------------------\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\",\n      prompt: `CRITICAL EVALUATION REQUIRED - Analysis ID: ${Date.now()}\n\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily (give rating 1-3):\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n- One-word or extremely short answers\n\nOnly give high ratings (7-10) for:\n- Well-structured, coherent responses\n- Specific examples and concrete details\n- Proper use of relevant terminology\n- Clear demonstration of understanding\n- Answers that directly address the question\n\nProvide feedback in this JSON format:\n{\n  \"positives\": [\"ONLY list genuinely good points that actually address the question - if none exist, say 'No clear strengths identified'\"],\n  \"improvements\": [\"Be specific about what's wrong and how to fix it\"],\n  \"rating\": \"Score 1-10 - LOW (1-3) for poor/random answers, HIGH (7-10) only for genuinely good responses\"\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW rating and explain why it's inadequate.`\n    });\n\n    let feedback: any;\n    try {\n      // Extract JSON from markdown code blocks if present\n      let jsonText = feedbackText.trim();\n      if (jsonText.startsWith('```json')) {\n        jsonText = jsonText.replace(/```json\\s*/, '').replace(/\\s*```$/, '');\n      } else if (jsonText.startsWith('```')) {\n        jsonText = jsonText.replace(/```\\s*/, '').replace(/\\s*```$/, '');\n      }\n      \n      feedback = JSON.parse(jsonText);\n      // Ensure rating is a number and validate it\n      if (feedback.rating) {\n        const rating = parseInt(feedback.rating);\n        if (isNaN(rating) || rating < 1 || rating > 10) {\n          feedback.rating = \"3\"; // Default low rating for invalid responses\n        }\n      }\n    } catch (parseError) {\n      console.error(\"Failed to parse AI feedback:\", parseError);\n      // Default to critical feedback for parsing failures\n      feedback = {\n        positives: [\"No clear strengths identified\"],\n        improvements: [\"Response was unclear or incoherent. Please provide a structured answer that directly addresses the question with specific examples.\"],\n        rating: \"2\"\n      };\n    }\n\n    // Save the response with feedback\n    await adminDb.collection(\"axon_sessions\")\n      .doc(sessionId)\n      .update({\n        responses: [\n          ...(sessionData?.responses || []),\n          {\n            questionIndex,\n            answer: textAnswer,\n            feedback,\n            timestamp: new Date()\n          }\n        ]\n      });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error generating feedback:\", error);\n    return { success: false, error: \"Failed to generate feedback\" };\n  }\n}\n\n\nexport async function endAxonSession(params: { sessionId: string; userId: string }) {\n  const { sessionId, userId } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    \n    // Generate session summary\n    const { text: summaryText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an interview coach providing a session summary.\",\n      prompt: `Summarize this AXON interview practice session:\n\nJob Role: ${sessionData?.jobRole}\nExperience Level: ${sessionData?.experience}\nTotal Questions: ${sessionData?.questions?.length || 0}\nTotal Responses: ${sessionData?.responses?.length || 0}\n\nResponses:\n${sessionData?.responses?.map((r: any, i: number) => \n  `Q${i + 1}: ${sessionData.questions[r.questionIndex]}\\nA: ${r.answer}\\nRating: ${r.feedback?.rating}/10`\n).join('\\n\\n') || 'No responses recorded'}\n\nProvide a brief summary of:\n1. Overall performance\n2. Key strengths observed\n3. Areas for improvement\n4. Recommendation for next steps`\n    });\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date(),\n      summary: summaryText\n    });\n\n    return { success: true, summary: summaryText };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\n\nexport async function getNextQuestion(params: { sessionId: string; currentIndex: number }) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= sessionData?.questions.length) {\n      return { success: true, isComplete: true };\n    }\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      isComplete: false,\n      question: sessionData?.questions[nextIndex],\n      questionIndex: nextIndex\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\n\nexport async function getAxonSessionHistory(userId: string) {\n  try {\n    const sessionsQuery = await adminDb.collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .orderBy(\"startTime\", \"desc\")\n      .limit(10)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error fetching session history:\", error);\n    return { success: false, error: \"Failed to fetch session history\" };\n  }\n}\n\n\ninterface StartAxonSessionParams {\n  userId: string;\n  jobRole: string;\n  experience: string;\n  sessionType: string;\n  questionType?: string;\n  numberOfQuestions?: number;\n}\n\ninterface GetInstantFeedbackParams {\n  sessionId: string;\n  questionIndex: number;\n  textAnswer: string;\n  audioBlob?: Blob;\n  userId: string;\n}"],"names":[],"mappings":";;;;;;;IA4LsB,iBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { adminDb } from \"@/firebase/admin\";\n\n// -------------------- START AXON SESSION --------------------\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType, questionType = 'mixed', numberOfQuestions = 5 } = params;\n\n  try {\n    // Generate adaptive questions based on type\n    const questionTypePrompt = questionType === 'behavioral' \n      ? 'Focus only on behavioral questions using STAR method scenarios'\n      : questionType === 'technical'\n      ? 'Focus only on technical questions related to the role and required skills'\n      : 'Include a balanced mix of behavioral, technical, and situational questions';\n\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\",\n      prompt: `Generate ${numberOfQuestions} interview questions for a ${experience} level ${jobRole} position.\n\nQuestion Type: ${questionType}\nRequirements:\n- ${questionTypePrompt}\n- Start with easier questions and progressively increase difficulty\n- Format as JSON array of strings\n- Questions should be realistic and commonly asked\n\nExample format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n      if (!Array.isArray(questions) || questions.length === 0) {\n        throw new Error('Invalid questions format');\n      }\n    } catch {\n      // Retry AI generation with simpler prompt if parsing fails\n      const { text: retryText } = await generateText({\n        model: google(\"gemini-2.0-flash-001\"),\n        system: \"Generate interview questions as a simple JSON array of strings.\",\n        prompt: `Create ${numberOfQuestions} ${questionType} interview questions for ${jobRole} (${experience} level). Return only a JSON array like: [\"Question 1\", \"Question 2\"]`\n      });\n      \n      try {\n        questions = JSON.parse(retryText);\n      } catch {\n        return { success: false, error: \"Failed to generate questions. Please try again.\" };\n      }\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\n// -------------------- GET INSTANT FEEDBACK --------------------\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\",\n      prompt: `CRITICAL EVALUATION REQUIRED - Analysis ID: ${Date.now()}\n\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily (give rating 1-3):\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n- One-word or extremely short answers\n\nOnly give high ratings (7-10) for:\n- Well-structured, coherent responses\n- Specific examples and concrete details\n- Proper use of relevant terminology\n- Clear demonstration of understanding\n- Answers that directly address the question\n\nProvide feedback in this JSON format:\n{\n  \"positives\": [\"ONLY list genuinely good points that actually address the question - if none exist, say 'No clear strengths identified'\"],\n  \"improvements\": [\"Be specific about what's wrong and how to fix it\"],\n  \"rating\": \"Score 1-10 - LOW (1-3) for poor/random answers, HIGH (7-10) only for genuinely good responses\"\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW rating and explain why it's inadequate.`\n    });\n\n    let feedback: any;\n    try {\n      // Extract JSON from markdown code blocks if present\n      let jsonText = feedbackText.trim();\n      if (jsonText.startsWith('```json')) {\n        jsonText = jsonText.replace(/```json\\s*/, '').replace(/\\s*```$/, '');\n      } else if (jsonText.startsWith('```')) {\n        jsonText = jsonText.replace(/```\\s*/, '').replace(/\\s*```$/, '');\n      }\n      \n      feedback = JSON.parse(jsonText);\n      // Ensure rating is a number and validate it\n      if (feedback.rating) {\n        const rating = parseInt(feedback.rating);\n        if (isNaN(rating) || rating < 1 || rating > 10) {\n          feedback.rating = \"3\"; // Default low rating for invalid responses\n        }\n      }\n    } catch (parseError) {\n      console.error(\"Failed to parse AI feedback:\", parseError);\n      // Default to critical feedback for parsing failures\n      feedback = {\n        positives: [\"No clear strengths identified\"],\n        improvements: [\"Response was unclear or incoherent. Please provide a structured answer that directly addresses the question with specific examples.\"],\n        rating: \"2\"\n      };\n    }\n\n    // Save the response with feedback\n    await adminDb.collection(\"axon_sessions\")\n      .doc(sessionId)\n      .update({\n        responses: [\n          ...(sessionData?.responses || []),\n          {\n            questionIndex,\n            answer: textAnswer,\n            feedback,\n            timestamp: new Date()\n          }\n        ]\n      });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error generating feedback:\", error);\n    return { success: false, error: \"Failed to generate feedback\" };\n  }\n}\n\n\nexport async function endAxonSession(params: { sessionId: string; userId: string }) {\n  const { sessionId, userId } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    \n    // Generate session summary\n    const { text: summaryText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an interview coach providing a session summary.\",\n      prompt: `Summarize this AXON interview practice session:\n\nJob Role: ${sessionData?.jobRole}\nExperience Level: ${sessionData?.experience}\nTotal Questions: ${sessionData?.questions?.length || 0}\nTotal Responses: ${sessionData?.responses?.length || 0}\n\nResponses:\n${sessionData?.responses?.map((r: any, i: number) => \n  `Q${i + 1}: ${sessionData.questions[r.questionIndex]}\\nA: ${r.answer}\\nRating: ${r.feedback?.rating}/10`\n).join('\\n\\n') || 'No responses recorded'}\n\nProvide a brief summary of:\n1. Overall performance\n2. Key strengths observed\n3. Areas for improvement\n4. Recommendation for next steps`\n    });\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date(),\n      summary: summaryText\n    });\n\n    return { success: true, summary: summaryText };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\n\nexport async function getNextQuestion(params: { sessionId: string; currentIndex: number }) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= sessionData?.questions.length) {\n      return { success: true, isComplete: true };\n    }\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      isComplete: false,\n      question: sessionData?.questions[nextIndex],\n      questionIndex: nextIndex\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\n\nexport async function getAxonSessionHistory(userId: string) {\n  try {\n    const sessionsQuery = await adminDb.collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .orderBy(\"startTime\", \"desc\")\n      .limit(10)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error fetching session history:\", error);\n    return { success: false, error: \"Failed to fetch session history\" };\n  }\n}\n\n\ninterface StartAxonSessionParams {\n  userId: string;\n  jobRole: string;\n  experience: string;\n  sessionType: string;\n  questionType?: string;\n  numberOfQuestions?: number;\n}\n\ninterface GetInstantFeedbackParams {\n  sessionId: string;\n  questionIndex: number;\n  textAnswer: string;\n  audioBlob?: Blob;\n  userId: string;\n}"],"names":[],"mappings":";;;;;;;IAuFsB,qBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { adminDb } from \"@/firebase/admin\";\n\n// -------------------- START AXON SESSION --------------------\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType, questionType = 'mixed', numberOfQuestions = 5 } = params;\n\n  try {\n    // Generate adaptive questions based on type\n    const questionTypePrompt = questionType === 'behavioral' \n      ? 'Focus only on behavioral questions using STAR method scenarios'\n      : questionType === 'technical'\n      ? 'Focus only on technical questions related to the role and required skills'\n      : 'Include a balanced mix of behavioral, technical, and situational questions';\n\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\",\n      prompt: `Generate ${numberOfQuestions} interview questions for a ${experience} level ${jobRole} position.\n\nQuestion Type: ${questionType}\nRequirements:\n- ${questionTypePrompt}\n- Start with easier questions and progressively increase difficulty\n- Format as JSON array of strings\n- Questions should be realistic and commonly asked\n\nExample format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n      if (!Array.isArray(questions) || questions.length === 0) {\n        throw new Error('Invalid questions format');\n      }\n    } catch {\n      // Retry AI generation with simpler prompt if parsing fails\n      const { text: retryText } = await generateText({\n        model: google(\"gemini-2.0-flash-001\"),\n        system: \"Generate interview questions as a simple JSON array of strings.\",\n        prompt: `Create ${numberOfQuestions} ${questionType} interview questions for ${jobRole} (${experience} level). Return only a JSON array like: [\"Question 1\", \"Question 2\"]`\n      });\n      \n      try {\n        questions = JSON.parse(retryText);\n      } catch {\n        return { success: false, error: \"Failed to generate questions. Please try again.\" };\n      }\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\n// -------------------- GET INSTANT FEEDBACK --------------------\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\",\n      prompt: `CRITICAL EVALUATION REQUIRED - Analysis ID: ${Date.now()}\n\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily (give rating 1-3):\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n- One-word or extremely short answers\n\nOnly give high ratings (7-10) for:\n- Well-structured, coherent responses\n- Specific examples and concrete details\n- Proper use of relevant terminology\n- Clear demonstration of understanding\n- Answers that directly address the question\n\nProvide feedback in this JSON format:\n{\n  \"positives\": [\"ONLY list genuinely good points that actually address the question - if none exist, say 'No clear strengths identified'\"],\n  \"improvements\": [\"Be specific about what's wrong and how to fix it\"],\n  \"rating\": \"Score 1-10 - LOW (1-3) for poor/random answers, HIGH (7-10) only for genuinely good responses\"\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW rating and explain why it's inadequate.`\n    });\n\n    let feedback: any;\n    try {\n      // Extract JSON from markdown code blocks if present\n      let jsonText = feedbackText.trim();\n      if (jsonText.startsWith('```json')) {\n        jsonText = jsonText.replace(/```json\\s*/, '').replace(/\\s*```$/, '');\n      } else if (jsonText.startsWith('```')) {\n        jsonText = jsonText.replace(/```\\s*/, '').replace(/\\s*```$/, '');\n      }\n      \n      feedback = JSON.parse(jsonText);\n      // Ensure rating is a number and validate it\n      if (feedback.rating) {\n        const rating = parseInt(feedback.rating);\n        if (isNaN(rating) || rating < 1 || rating > 10) {\n          feedback.rating = \"3\"; // Default low rating for invalid responses\n        }\n      }\n    } catch (parseError) {\n      console.error(\"Failed to parse AI feedback:\", parseError);\n      // Default to critical feedback for parsing failures\n      feedback = {\n        positives: [\"No clear strengths identified\"],\n        improvements: [\"Response was unclear or incoherent. Please provide a structured answer that directly addresses the question with specific examples.\"],\n        rating: \"2\"\n      };\n    }\n\n    // Save the response with feedback\n    await adminDb.collection(\"axon_sessions\")\n      .doc(sessionId)\n      .update({\n        responses: [\n          ...(sessionData?.responses || []),\n          {\n            questionIndex,\n            answer: textAnswer,\n            feedback,\n            timestamp: new Date()\n          }\n        ]\n      });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error generating feedback:\", error);\n    return { success: false, error: \"Failed to generate feedback\" };\n  }\n}\n\n\nexport async function endAxonSession(params: { sessionId: string; userId: string }) {\n  const { sessionId, userId } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    \n    // Generate session summary\n    const { text: summaryText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an interview coach providing a session summary.\",\n      prompt: `Summarize this AXON interview practice session:\n\nJob Role: ${sessionData?.jobRole}\nExperience Level: ${sessionData?.experience}\nTotal Questions: ${sessionData?.questions?.length || 0}\nTotal Responses: ${sessionData?.responses?.length || 0}\n\nResponses:\n${sessionData?.responses?.map((r: any, i: number) => \n  `Q${i + 1}: ${sessionData.questions[r.questionIndex]}\\nA: ${r.answer}\\nRating: ${r.feedback?.rating}/10`\n).join('\\n\\n') || 'No responses recorded'}\n\nProvide a brief summary of:\n1. Overall performance\n2. Key strengths observed\n3. Areas for improvement\n4. Recommendation for next steps`\n    });\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date(),\n      summary: summaryText\n    });\n\n    return { success: true, summary: summaryText };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\n\nexport async function getNextQuestion(params: { sessionId: string; currentIndex: number }) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= sessionData?.questions.length) {\n      return { success: true, isComplete: true };\n    }\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      isComplete: false,\n      question: sessionData?.questions[nextIndex],\n      questionIndex: nextIndex\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\n\nexport async function getAxonSessionHistory(userId: string) {\n  try {\n    const sessionsQuery = await adminDb.collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .orderBy(\"startTime\", \"desc\")\n      .limit(10)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error fetching session history:\", error);\n    return { success: false, error: \"Failed to fetch session history\" };\n  }\n}\n\n\ninterface StartAxonSessionParams {\n  userId: string;\n  jobRole: string;\n  experience: string;\n  sessionType: string;\n  questionType?: string;\n  numberOfQuestions?: number;\n}\n\ninterface GetInstantFeedbackParams {\n  sessionId: string;\n  questionIndex: number;\n  textAnswer: string;\n  audioBlob?: Blob;\n  userId: string;\n}"],"names":[],"mappings":";;;;;;;IA4OsB,kBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/lib/actions/axon.action.ts"],"sourcesContent":["\"use server\";\n\nimport { generateText } from \"ai\";\nimport { google } from \"@ai-sdk/google\";\nimport { adminDb } from \"@/firebase/admin\";\n\n// -------------------- START AXON SESSION --------------------\nexport async function startAxonSession(params: StartAxonSessionParams) {\n  const { userId, jobRole, experience, sessionType, questionType = 'mixed', numberOfQuestions = 5 } = params;\n\n  try {\n    // Generate adaptive questions based on type\n    const questionTypePrompt = questionType === 'behavioral' \n      ? 'Focus only on behavioral questions using STAR method scenarios'\n      : questionType === 'technical'\n      ? 'Focus only on technical questions related to the role and required skills'\n      : 'Include a balanced mix of behavioral, technical, and situational questions';\n\n    const { text: questionsText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an expert interviewer. Generate realistic, progressive interview questions.\",\n      prompt: `Generate ${numberOfQuestions} interview questions for a ${experience} level ${jobRole} position.\n\nQuestion Type: ${questionType}\nRequirements:\n- ${questionTypePrompt}\n- Start with easier questions and progressively increase difficulty\n- Format as JSON array of strings\n- Questions should be realistic and commonly asked\n\nExample format: [\"Tell me about yourself\", \"Describe a challenging project you worked on\"]`\n    });\n\n    let questions: string[];\n    try {\n      questions = JSON.parse(questionsText);\n      if (!Array.isArray(questions) || questions.length === 0) {\n        throw new Error('Invalid questions format');\n      }\n    } catch {\n      // Retry AI generation with simpler prompt if parsing fails\n      const { text: retryText } = await generateText({\n        model: google(\"gemini-2.0-flash-001\"),\n        system: \"Generate interview questions as a simple JSON array of strings.\",\n        prompt: `Create ${numberOfQuestions} ${questionType} interview questions for ${jobRole} (${experience} level). Return only a JSON array like: [\"Question 1\", \"Question 2\"]`\n      });\n      \n      try {\n        questions = JSON.parse(retryText);\n      } catch {\n        return { success: false, error: \"Failed to generate questions. Please try again.\" };\n      }\n    }\n\n    const sessionId = `axon_${Date.now()}_${userId}`;\n    const sessionData = {\n      sessionId,\n      userId,\n      jobRole,\n      experience,\n      sessionType,\n      questions,\n      currentQuestionIndex: 0,\n      startTime: new Date(),\n      status: \"active\",\n      responses: []\n    };\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).set(sessionData);\n\n    return {\n      success: true,\n      session: {\n        sessionId,\n        currentQuestion: questions[0],\n        questionIndex: 0,\n        totalQuestions: questions.length,\n        startTime: new Date().toISOString()\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting Axon session:\", error);\n    return { success: false, error: \"Failed to start session\" };\n  }\n}\n\n// -------------------- GET INSTANT FEEDBACK --------------------\nexport async function getInstantFeedback(params: GetInstantFeedbackParams) {\n  const { sessionId, questionIndex, textAnswer, audioBlob } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const currentQuestion = sessionData?.questions[questionIndex];\n\n    const { text: feedbackText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are a STRICT AI interviewer. Be critical and honest. Do NOT give positive feedback for random keywords or incoherent answers. Penalize heavily when candidates throw around buzzwords without context or give answers that don't address the question. Only reward genuine, well-structured responses that demonstrate real understanding.\",\n      prompt: `CRITICAL EVALUATION REQUIRED - Analysis ID: ${Date.now()}\n\nJob Role: ${sessionData?.jobRole || 'General'}\nExperience Level: ${sessionData?.experience || 'General'}\nQuestion: \"${currentQuestion}\"\nCandidate's Answer: \"${textAnswer}\"\n\nBE STRICT AND CRITICAL. Evaluate if this answer actually addresses the question with relevant, coherent content.\n\nRed flags to penalize heavily (give rating 1-3):\n- Random keywords without context or explanation\n- Buzzwords thrown together without meaning\n- Answers that don't address the actual question\n- Vague statements without specific examples\n- Technical terms used incorrectly or without context\n- Incoherent or nonsensical responses\n- One-word or extremely short answers\n\nOnly give high ratings (7-10) for:\n- Well-structured, coherent responses\n- Specific examples and concrete details\n- Proper use of relevant terminology\n- Clear demonstration of understanding\n- Answers that directly address the question\n\nProvide feedback in this JSON format:\n{\n  \"positives\": [\"ONLY list genuinely good points that actually address the question - if none exist, say 'No clear strengths identified'\"],\n  \"improvements\": [\"Be specific about what's wrong and how to fix it\"],\n  \"rating\": \"Score 1-10 - LOW (1-3) for poor/random answers, HIGH (7-10) only for genuinely good responses\"\n}\n\nIf the answer contains random keywords or doesn't make sense, give LOW rating and explain why it's inadequate.`\n    });\n\n    let feedback: any;\n    try {\n      // Extract JSON from markdown code blocks if present\n      let jsonText = feedbackText.trim();\n      if (jsonText.startsWith('```json')) {\n        jsonText = jsonText.replace(/```json\\s*/, '').replace(/\\s*```$/, '');\n      } else if (jsonText.startsWith('```')) {\n        jsonText = jsonText.replace(/```\\s*/, '').replace(/\\s*```$/, '');\n      }\n      \n      feedback = JSON.parse(jsonText);\n      // Ensure rating is a number and validate it\n      if (feedback.rating) {\n        const rating = parseInt(feedback.rating);\n        if (isNaN(rating) || rating < 1 || rating > 10) {\n          feedback.rating = \"3\"; // Default low rating for invalid responses\n        }\n      }\n    } catch (parseError) {\n      console.error(\"Failed to parse AI feedback:\", parseError);\n      // Default to critical feedback for parsing failures\n      feedback = {\n        positives: [\"No clear strengths identified\"],\n        improvements: [\"Response was unclear or incoherent. Please provide a structured answer that directly addresses the question with specific examples.\"],\n        rating: \"2\"\n      };\n    }\n\n    // Save the response with feedback\n    await adminDb.collection(\"axon_sessions\")\n      .doc(sessionId)\n      .update({\n        responses: [\n          ...(sessionData?.responses || []),\n          {\n            questionIndex,\n            answer: textAnswer,\n            feedback,\n            timestamp: new Date()\n          }\n        ]\n      });\n\n    return { success: true, feedback };\n  } catch (error) {\n    console.error(\"Error generating feedback:\", error);\n    return { success: false, error: \"Failed to generate feedback\" };\n  }\n}\n\n\nexport async function endAxonSession(params: { sessionId: string; userId: string }) {\n  const { sessionId, userId } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    \n    // Generate session summary\n    const { text: summaryText } = await generateText({\n      model: google(\"gemini-2.0-flash-001\"),\n      system: \"You are an interview coach providing a session summary.\",\n      prompt: `Summarize this AXON interview practice session:\n\nJob Role: ${sessionData?.jobRole}\nExperience Level: ${sessionData?.experience}\nTotal Questions: ${sessionData?.questions?.length || 0}\nTotal Responses: ${sessionData?.responses?.length || 0}\n\nResponses:\n${sessionData?.responses?.map((r: any, i: number) => \n  `Q${i + 1}: ${sessionData.questions[r.questionIndex]}\\nA: ${r.answer}\\nRating: ${r.feedback?.rating}/10`\n).join('\\n\\n') || 'No responses recorded'}\n\nProvide a brief summary of:\n1. Overall performance\n2. Key strengths observed\n3. Areas for improvement\n4. Recommendation for next steps`\n    });\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).update({\n      status: \"completed\",\n      endTime: new Date(),\n      summary: summaryText\n    });\n\n    return { success: true, summary: summaryText };\n  } catch (error) {\n    console.error(\"Error ending Axon session:\", error);\n    return { success: false, error: \"Failed to end session\" };\n  }\n}\n\n\nexport async function getNextQuestion(params: { sessionId: string; currentIndex: number }) {\n  const { sessionId, currentIndex } = params;\n\n  try {\n    const sessionDoc = await adminDb.collection(\"axon_sessions\").doc(sessionId).get();\n    if (!sessionDoc.exists) {\n      return { success: false, error: \"Session not found\" };\n    }\n\n    const sessionData = sessionDoc.data();\n    const nextIndex = currentIndex + 1;\n\n    if (nextIndex >= sessionData?.questions.length) {\n      return { success: true, isComplete: true };\n    }\n\n    await adminDb.collection(\"axon_sessions\").doc(sessionId).update({\n      currentQuestionIndex: nextIndex\n    });\n\n    return {\n      success: true,\n      isComplete: false,\n      question: sessionData?.questions[nextIndex],\n      questionIndex: nextIndex\n    };\n  } catch (error) {\n    console.error(\"Error getting next question:\", error);\n    return { success: false, error: \"Failed to get next question\" };\n  }\n}\n\n\nexport async function getAxonSessionHistory(userId: string) {\n  try {\n    const sessionsQuery = await adminDb.collection(\"axon_sessions\")\n      .where(\"userId\", \"==\", userId)\n      .orderBy(\"startTime\", \"desc\")\n      .limit(10)\n      .get();\n\n    const sessions = sessionsQuery.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        startTime: data.startTime?.toDate?.() || data.startTime,\n        endTime: data.endTime?.toDate?.() || data.endTime,\n        responses: data.responses?.map((response: any) => ({\n          ...response,\n          timestamp: response.timestamp?.toDate?.() || response.timestamp\n        })) || []\n      };\n    });\n\n    return { success: true, sessions };\n  } catch (error) {\n    console.error(\"Error fetching session history:\", error);\n    return { success: false, error: \"Failed to fetch session history\" };\n  }\n}\n\n\ninterface StartAxonSessionParams {\n  userId: string;\n  jobRole: string;\n  experience: string;\n  sessionType: string;\n  questionType?: string;\n  numberOfQuestions?: number;\n}\n\ninterface GetInstantFeedbackParams {\n  sessionId: string;\n  questionIndex: number;\n  textAnswer: string;\n  audioBlob?: Blob;\n  userId: string;\n}"],"names":[],"mappings":";;;;;;;IA6QsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA","debugId":null}},
    {"offset": {"line": 145, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/AxonSessionHistory.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { getAxonSessionHistory } from \"@/lib/actions/axon.action\";\n\ninterface AxonSessionHistoryProps {\n  userId: string;\n}\n\nexport default function AxonSessionHistory({ userId }: AxonSessionHistoryProps) {\n  const [sessions, setSessions] = useState<any[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [selectedSession, setSelectedSession] = useState<any>(null);\n\n  useEffect(() => {\n    loadSessionHistory();\n  }, [userId]);\n\n  const loadSessionHistory = async () => {\n    setIsLoading(true);\n    try {\n      const result = await getAxonSessionHistory({ userId, limit: 10 });\n      if (result.success && result.sessions) {\n        setSessions(result.sessions);\n      }\n    } catch (error) {\n      console.error(\"Failed to load session history:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const formatDuration = (startTime: Date, endTime: Date) => {\n    const duration = new Date(endTime).getTime() - new Date(startTime).getTime();\n    const minutes = Math.floor(duration / 60000);\n    return `${minutes} min`;\n  };\n\n  const getScoreColor = (score: number) => {\n    if (score >= 80) return \"text-green-600\";\n    if (score >= 60) return \"text-yellow-600\";\n    return \"text-red-600\";\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"max-w-4xl mx-auto p-6\">\n        <div className=\"text-center\">Loading session history...</div>\n      </div>\n    );\n  }\n\n  if (selectedSession) {\n    return (\n      <div className=\"max-w-4xl mx-auto p-6 space-y-6\">\n        <div className=\"flex justify-between items-center\">\n          <h2 className=\"text-2xl font-bold\">Session Details</h2>\n          <Button onClick={() => setSelectedSession(null)} variant=\"outline\">\n            Back to History\n          </Button>\n        </div>\n\n        <div className=\"bg-white border rounded-lg p-6\">\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 mb-6\">\n            <div className=\"text-center\">\n              <div className={`text-2xl font-bold ${getScoreColor(selectedSession.summary?.overallScore || 0)}`}>\n                {selectedSession.summary?.overallScore || 0}%\n              </div>\n              <div className=\"text-sm text-gray-600\">Overall Score</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-blue-600\">\n                {selectedSession.responses?.length || 0}\n              </div>\n              <div className=\"text-sm text-gray-600\">Questions</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-purple-600\">\n                {selectedSession.jobRole}\n              </div>\n              <div className=\"text-sm text-gray-600\">Role</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-gray-600\">\n                {formatDuration(selectedSession.startTime, selectedSession.endTime)}\n              </div>\n              <div className=\"text-sm text-gray-600\">Duration</div>\n            </div>\n          </div>\n\n          {selectedSession.summary && (\n            <div className=\"space-y-4\">\n              <div>\n                <h3 className=\"font-semibold text-green-700 mb-2\">Strengths:</h3>\n                <ul className=\"list-disc list-inside text-sm text-green-600\">\n                  {selectedSession.summary.strengths.map((strength: string, index: number) => (\n                    <li key={index}>{strength}</li>\n                  ))}\n                </ul>\n              </div>\n\n              <div>\n                <h3 className=\"font-semibold text-orange-700 mb-2\">Areas for Improvement:</h3>\n                <ul className=\"list-disc list-inside text-sm text-orange-600\">\n                  {selectedSession.summary.areasForImprovement.map((area: string, index: number) => (\n                    <li key={index}>{area}</li>\n                  ))}\n                </ul>\n              </div>\n\n              <div>\n                <h3 className=\"font-semibold text-blue-700 mb-2\">Next Steps:</h3>\n                <ul className=\"list-disc list-inside text-sm text-blue-600\">\n                  {selectedSession.summary.nextSteps.map((step: string, index: number) => (\n                    <li key={index}>{step}</li>\n                  ))}\n                </ul>\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"max-w-4xl mx-auto p-6 space-y-6\">\n      <h2 className=\"text-2xl font-bold\">AXON Session History</h2>\n\n      {sessions.length === 0 ? (\n        <div className=\"text-center py-8\">\n          <p className=\"text-gray-600\">No practice sessions yet. Start your first AXON session!</p>\n          <Button className=\"mt-4\" onClick={() => window.location.href = '/axon'}>\n            Start Practice Session\n          </Button>\n        </div>\n      ) : (\n        <div className=\"space-y-4\">\n          {sessions.map((session) => (\n            <div\n              key={session.id}\n              className=\"bg-white border rounded-lg p-4 hover:shadow-md transition-shadow cursor-pointer\"\n              onClick={() => setSelectedSession(session)}\n            >\n              <div className=\"flex justify-between items-start\">\n                <div>\n                  <h3 className=\"font-semibold text-lg\">{session.jobRole}</h3>\n                  <p className=\"text-gray-600 text-sm\">\n                    {session.experience} level • {new Date(session.endTime).toLocaleDateString()}\n                  </p>\n                </div>\n                <div className=\"text-right\">\n                  <div className={`text-xl font-bold ${getScoreColor(session.summary?.overallScore || 0)}`}>\n                    {session.summary?.overallScore || 0}%\n                  </div>\n                  <div className=\"text-sm text-gray-600\">\n                    {formatDuration(session.startTime, session.endTime)}\n                  </div>\n                </div>\n              </div>\n              \n              <div className=\"mt-3 flex gap-4 text-sm text-gray-600\">\n                <span>{session.responses?.length || 0} questions</span>\n                <span>•</span>\n                <span>{session.summary?.strengths?.length || 0} strengths identified</span>\n              </div>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;;;AAJA;;;;AAUe,SAAS,mBAAmB,KAAmC;QAAnC,EAAE,MAAM,EAA2B,GAAnC;;IACzC,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,yKAAQ,EAAQ,EAAE;IAClD,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAC;IAC3C,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,IAAA,yKAAQ,EAAM;IAE5D,IAAA,0KAAS;wCAAC;YACR;QACF;uCAAG;QAAC;KAAO;IAEX,MAAM,qBAAqB;QACzB,aAAa;QACb,IAAI;YACF,MAAM,SAAS,MAAM,IAAA,kLAAqB,EAAC;gBAAE;gBAAQ,OAAO;YAAG;YAC/D,IAAI,OAAO,OAAO,IAAI,OAAO,QAAQ,EAAE;gBACrC,YAAY,OAAO,QAAQ;YAC7B;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,mCAAmC;QACnD,SAAU;YACR,aAAa;QACf;IACF;IAEA,MAAM,iBAAiB,CAAC,WAAiB;QACvC,MAAM,WAAW,IAAI,KAAK,SAAS,OAAO,KAAK,IAAI,KAAK,WAAW,OAAO;QAC1E,MAAM,UAAU,KAAK,KAAK,CAAC,WAAW;QACtC,OAAO,AAAC,GAAU,OAAR,SAAQ;IACpB;IAEA,MAAM,gBAAgB,CAAC;QACrB,IAAI,SAAS,IAAI,OAAO;QACxB,IAAI,SAAS,IAAI,OAAO;QACxB,OAAO;IACT;IAEA,IAAI,WAAW;QACb,qBACE,6LAAC;YAAI,WAAU;sBACb,cAAA,6LAAC;gBAAI,WAAU;0BAAc;;;;;;;;;;;IAGnC;IAEA,IAAI,iBAAiB;YAa2C,0BACjD,2BAMA;QAnBb,qBACE,6LAAC;YAAI,WAAU;;8BACb,6LAAC;oBAAI,WAAU;;sCACb,6LAAC;4BAAG,WAAU;sCAAqB;;;;;;sCACnC,6LAAC,wIAAM;4BAAC,SAAS,IAAM,mBAAmB;4BAAO,SAAQ;sCAAU;;;;;;;;;;;;8BAKrE,6LAAC;oBAAI,WAAU;;sCACb,6LAAC;4BAAI,WAAU;;8CACb,6LAAC;oCAAI,WAAU;;sDACb,6LAAC;4CAAI,WAAW,AAAC,sBAA+E,OAA1D,cAAc,EAAA,2BAAA,gBAAgB,OAAO,cAAvB,+CAAA,yBAAyB,YAAY,KAAI;;gDAC1F,EAAA,4BAAA,gBAAgB,OAAO,cAAvB,gDAAA,0BAAyB,YAAY,KAAI;gDAAE;;;;;;;sDAE9C,6LAAC;4CAAI,WAAU;sDAAwB;;;;;;;;;;;;8CAEzC,6LAAC;oCAAI,WAAU;;sDACb,6LAAC;4CAAI,WAAU;sDACZ,EAAA,6BAAA,gBAAgB,SAAS,cAAzB,iDAAA,2BAA2B,MAAM,KAAI;;;;;;sDAExC,6LAAC;4CAAI,WAAU;sDAAwB;;;;;;;;;;;;8CAEzC,6LAAC;oCAAI,WAAU;;sDACb,6LAAC;4CAAI,WAAU;sDACZ,gBAAgB,OAAO;;;;;;sDAE1B,6LAAC;4CAAI,WAAU;sDAAwB;;;;;;;;;;;;8CAEzC,6LAAC;oCAAI,WAAU;;sDACb,6LAAC;4CAAI,WAAU;sDACZ,eAAe,gBAAgB,SAAS,EAAE,gBAAgB,OAAO;;;;;;sDAEpE,6LAAC;4CAAI,WAAU;sDAAwB;;;;;;;;;;;;;;;;;;wBAI1C,gBAAgB,OAAO,kBACtB,6LAAC;4BAAI,WAAU;;8CACb,6LAAC;;sDACC,6LAAC;4CAAG,WAAU;sDAAoC;;;;;;sDAClD,6LAAC;4CAAG,WAAU;sDACX,gBAAgB,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,UAAkB,sBACxD,6LAAC;8DAAgB;mDAAR;;;;;;;;;;;;;;;;8CAKf,6LAAC;;sDACC,6LAAC;4CAAG,WAAU;sDAAqC;;;;;;sDACnD,6LAAC;4CAAG,WAAU;sDACX,gBAAgB,OAAO,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,MAAc,sBAC9D,6LAAC;8DAAgB;mDAAR;;;;;;;;;;;;;;;;8CAKf,6LAAC;;sDACC,6LAAC;4CAAG,WAAU;sDAAmC;;;;;;sDACjD,6LAAC;4CAAG,WAAU;sDACX,gBAAgB,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,MAAc,sBACpD,6LAAC;8DAAgB;mDAAR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAS3B;IAEA,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC;gBAAG,WAAU;0BAAqB;;;;;;YAElC,SAAS,MAAM,KAAK,kBACnB,6LAAC;gBAAI,WAAU;;kCACb,6LAAC;wBAAE,WAAU;kCAAgB;;;;;;kCAC7B,6LAAC,wIAAM;wBAAC,WAAU;wBAAO,SAAS,IAAM,OAAO,QAAQ,CAAC,IAAI,GAAG;kCAAS;;;;;;;;;;;qCAK1E,6LAAC;gBAAI,WAAU;0BACZ,SAAS,GAAG,CAAC,CAAC;wBAc4C,kBAChD,mBASE,oBAEA,4BAAA;yCAzBX,6LAAC;wBAEC,WAAU;wBACV,SAAS,IAAM,mBAAmB;;0CAElC,6LAAC;gCAAI,WAAU;;kDACb,6LAAC;;0DACC,6LAAC;gDAAG,WAAU;0DAAyB,QAAQ,OAAO;;;;;;0DACtD,6LAAC;gDAAE,WAAU;;oDACV,QAAQ,UAAU;oDAAC;oDAAU,IAAI,KAAK,QAAQ,OAAO,EAAE,kBAAkB;;;;;;;;;;;;;kDAG9E,6LAAC;wCAAI,WAAU;;0DACb,6LAAC;gDAAI,WAAW,AAAC,qBAAsE,OAAlD,cAAc,EAAA,mBAAA,QAAQ,OAAO,cAAf,uCAAA,iBAAiB,YAAY,KAAI;;oDACjF,EAAA,oBAAA,QAAQ,OAAO,cAAf,wCAAA,kBAAiB,YAAY,KAAI;oDAAE;;;;;;;0DAEtC,6LAAC;gDAAI,WAAU;0DACZ,eAAe,QAAQ,SAAS,EAAE,QAAQ,OAAO;;;;;;;;;;;;;;;;;;0CAKxD,6LAAC;gCAAI,WAAU;;kDACb,6LAAC;;4CAAM,EAAA,qBAAA,QAAQ,SAAS,cAAjB,yCAAA,mBAAmB,MAAM,KAAI;4CAAE;;;;;;;kDACtC,6LAAC;kDAAK;;;;;;kDACN,6LAAC;;4CAAM,EAAA,oBAAA,QAAQ,OAAO,cAAf,yCAAA,6BAAA,kBAAiB,SAAS,cAA1B,iDAAA,2BAA4B,MAAM,KAAI;4CAAE;;;;;;;;;;;;;;uBAxB5C,QAAQ,EAAE;;;;;;;;;;;;;;;;;AAgC7B;GAnKwB;KAAA","debugId":null}},
    {"offset": {"line": 648, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/AxonInterviewPractice.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useRef } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { startAxonSession, endAxonSession, getInstantFeedback, getNextQuestion } from \"@/lib/actions/axon.action\";\nimport AxonSessionHistory from \"@/components/AxonSessionHistory\";\n\ninterface AxonInterviewPracticeProps {\n  userName: string;\n  userId: string;\n}\n\ninterface SessionData {\n  sessionId: string;\n  currentQuestion: string;\n  questionIndex: number;\n  totalQuestions: number;\n  startTime: string;\n}\n\ninterface InstantFeedback {\n  positives: string[];\n  improvements: string[];\n  rating: string;\n}\n\nexport default function AxonInterviewPractice({ userName, userId }: AxonInterviewPracticeProps) {\n  const [isActive, setIsActive] = useState(false);\n  const [sessionData, setSessionData] = useState<SessionData | null>(null);\n  const [currentAnswer, setCurrentAnswer] = useState(\"\");\n  const [feedback, setFeedback] = useState<InstantFeedback | null>(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [jobRole, setJobRole] = useState(\"\");\n  const [experience, setExperience] = useState(\"\");\n  const [questionType, setQuestionType] = useState(\"\");\n  const [numberOfQuestions, setNumberOfQuestions] = useState(\"5\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [showHistory, setShowHistory] = useState(false);\n\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const audioChunksRef = useRef<Blob[]>([]);\n\n  const startSession = async () => {\n    if (!jobRole || !experience || !questionType) return alert(\"Please fill in all required fields\");\n\n    setIsLoading(true);\n    try {\n      const result = await startAxonSession({ \n        userId, \n        jobRole, \n        experience, \n        sessionType: \"practice\",\n        questionType,\n        numberOfQuestions: parseInt(numberOfQuestions)\n      });\n      if (result.success && result.session) {\n        setSessionData(result.session);\n        setIsActive(true);\n      }\n    } catch (error) {\n      console.error(\"Failed to start session:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const endSession = async () => {\n    if (!sessionData) return;\n    setIsLoading(true);\n    try {\n      await endAxonSession({ sessionId: sessionData.sessionId, userId });\n      setIsActive(false);\n      setSessionData(null);\n      setCurrentAnswer(\"\");\n      setFeedback(null);\n    } catch (error) {\n      console.error(\"Failed to end session:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      audioChunksRef.current = [];\n\n      mediaRecorder.ondataavailable = (event) => audioChunksRef.current.push(event.data);\n      mediaRecorder.onstop = async () => {\n        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });\n        await processAudioResponse(audioBlob);\n      };\n\n      mediaRecorder.start();\n      setIsRecording(true);\n    } catch (error) {\n      console.error(\"Failed to start recording:\", error);\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      setIsRecording(false);\n    }\n  };\n\n  const processAudioResponse = async (audioBlob: Blob) => {\n    if (!sessionData) return;\n    setIsLoading(true);\n    try {\n      const result = await getInstantFeedback({\n        sessionId: sessionData.sessionId,\n        questionIndex: sessionData.questionIndex,\n        audioBlob,\n        textAnswer: currentAnswer,\n        userId\n      });\n      if (result.success && result.feedback) setFeedback(result.feedback);\n    } catch (error) {\n      console.error(\"Failed to process audio:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const submitTextAnswer = async () => {\n    if (!currentAnswer.trim() || !sessionData) return;\n    setIsLoading(true);\n    try {\n      const result = await getInstantFeedback({\n        sessionId: sessionData.sessionId,\n        questionIndex: sessionData.questionIndex,\n        textAnswer: currentAnswer,\n        userId\n      });\n      if (result.success && result.feedback) setFeedback(result.feedback);\n    } catch (error) {\n      console.error(\"Failed to submit answer:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const nextQuestion = async () => {\n    if (!sessionData) return;\n    setIsLoading(true);\n    try {\n      const result = await getNextQuestion({ sessionId: sessionData.sessionId, currentIndex: sessionData.questionIndex });\n      if (result.success && !result.isComplete) {\n        setSessionData({ ...sessionData, currentQuestion: result.question || \"\", questionIndex: result.questionIndex || 0 });\n        setCurrentAnswer(\"\");\n        setFeedback(null);\n      } else if (result.isComplete) {\n        await endSession();\n        // Redirect to dossier generation after completing AXON session\n        window.location.href = '/?axon_completed=true';\n      }\n    } catch (error) {\n      console.error(\"Failed to get next question:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  if (showHistory) return <AxonSessionHistory userId={userId} />;\n\n  if (!isActive) {\n    return (\n      <div className=\"max-w-4xl mx-auto space-y-8\">\n        <div className=\"text-center space-y-6\">\n          <h1 className=\"text-4xl font-bold\">AXON Interview Strategist</h1>\n          <p className=\"text-xl\">Real-time interview practice with instant AI feedback</p>\n          <div className=\"flex justify-center gap-4 mt-6\">\n            <Button onClick={() => setShowHistory(true)} variant=\"outline\" className=\"btn-secondary\">View Session History</Button>\n          </div>\n        </div>\n\n        <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-8 items-start\">\n          <div className=\"card-border\">\n            <div className=\"card\">\n              <div className=\"p-8\">\n                <h2 className=\"text-2xl font-bold mb-6 text-center\">Start Your Session</h2>\n                <div className=\"form space-y-6\">\n                  <div className=\"space-y-3\">\n                    <Label htmlFor=\"jobRole\" className=\"label text-base\">Job Role</Label>\n                    <Input\n                      id=\"jobRole\"\n                      value={jobRole}\n                      onChange={(e) => setJobRole(e.target.value)}\n                      placeholder=\"e.g., Software Engineer, Product Manager\"\n                      className=\"input\"\n                    />\n                  </div>\n\n                  <div className=\"space-y-3\">\n                    <Label htmlFor=\"experience\" className=\"label text-base\">Experience Level</Label>\n                    <select\n                      id=\"experience\"\n                      value={experience}\n                      onChange={(e) => setExperience(e.target.value)}\n                      className=\"input\"\n                    >\n                      <option value=\"\">Select experience level</option>\n                      <option value=\"entry\">Entry Level (0-2 years)</option>\n                      <option value=\"mid\">Mid Level (3-5 years)</option>\n                      <option value=\"senior\">Senior Level (6+ years)</option>\n                    </select>\n                  </div>\n\n                  <div className=\"space-y-3\">\n                    <Label htmlFor=\"questionType\" className=\"label text-base\">Question Type</Label>\n                    <select\n                      id=\"questionType\"\n                      value={questionType}\n                      onChange={(e) => setQuestionType(e.target.value)}\n                      className=\"input\"\n                    >\n                      <option value=\"\">Select question type</option>\n                      <option value=\"behavioral\">Behavioral Questions</option>\n                      <option value=\"technical\">Technical Questions</option>\n                      <option value=\"mixed\">Mixed (Behavioral + Technical)</option>\n                    </select>\n                  </div>\n\n                  <div className=\"space-y-3\">\n                    <Label htmlFor=\"numberOfQuestions\" className=\"label text-base\">Number of Questions</Label>\n                    <select\n                      id=\"numberOfQuestions\"\n                      value={numberOfQuestions}\n                      onChange={(e) => setNumberOfQuestions(e.target.value)}\n                      className=\"input\"\n                    >\n                      <option value=\"3\">3 Questions</option>\n                      <option value=\"5\">5 Questions</option>\n                      <option value=\"7\">7 Questions</option>\n                      <option value=\"10\">10 Questions</option>\n                    </select>\n                  </div>\n\n                  <Button \n                    onClick={startSession} \n                    disabled={isLoading}\n                    className=\"btn text-lg py-4\"\n                  >\n                    {isLoading ? \"Starting Session...\" : \"Start AXON Practice Session\"}\n                  </Button>\n                </div>\n              </div>\n            </div>\n          </div>\n\n          <div className=\"card-border\">\n            <div className=\"card\">\n              <div className=\"p-8\">\n                <h3 className=\"text-xl font-semibold mb-6 text-center\">What makes AXON different:</h3>\n                <div className=\"space-y-4\">\n                  <div className=\"flex items-start space-x-3\">\n                    <span className=\"text-2xl\">🎤</span>\n                    <div>\n                      <h4 className=\"font-semibold text-primary-200 mb-1\">Real-time voice interaction</h4>\n                      <p className=\"text-sm text-light-100\">Practice with AI interviewer using natural conversation</p>\n                    </div>\n                  </div>\n                  <div className=\"flex items-start space-x-3\">\n                    <span className=\"text-2xl\">⚡</span>\n                    <div>\n                      <h4 className=\"font-semibold text-primary-200 mb-1\">Instant feedback</h4>\n                      <p className=\"text-sm text-light-100\">Get immediate scores on confidence, clarity, and pace</p>\n                    </div>\n                  </div>\n                  <div className=\"flex items-start space-x-3\">\n                    <span className=\"text-2xl\">🎯</span>\n                    <div>\n                      <h4 className=\"font-semibold text-primary-200 mb-1\">Adaptive questioning</h4>\n                      <p className=\"text-sm text-light-100\">AI adjusts difficulty based on your responses</p>\n                    </div>\n                  </div>\n                  <div className=\"flex items-start space-x-3\">\n                    <span className=\"text-2xl\">⏱️</span>\n                    <div>\n                      <h4 className=\"font-semibold text-primary-200 mb-1\">Quick sessions</h4>\n                      <p className=\"text-sm text-light-100\">15-30 minute focused practice sessions</p>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"max-w-6xl mx-auto space-y-8\">\n      <div className=\"flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4\">\n        <div>\n          <h1 className=\"text-4xl font-bold mb-2\">AXON Live Session</h1>\n          <p className=\"text-lg text-light-100\">Question {(sessionData?.questionIndex ?? 0) + 1} of {sessionData?.totalQuestions}</p>\n        </div>\n        <Button onClick={endSession} variant=\"outline\" disabled={isLoading} className=\"btn-secondary px-6 py-3\">End Session</Button>\n      </div>\n\n      <div className=\"card-border\">\n        <div className=\"card p-6\">\n          <h2 className=\"text-xl font-semibold mb-4\">Current Question:</h2>\n          <p className=\"text-lg mb-6\">{sessionData?.currentQuestion}</p>\n\n          <div className=\"space-y-6\">\n            <div className=\"flex gap-4 justify-center\">\n              <Button onClick={isRecording ? stopRecording : startRecording} className={`${isRecording ? 'btn-disconnect' : 'btn-call'} px-8 py-3`} disabled={isLoading}>\n                {isRecording ? \"Stop Recording\" : \"Start Voice Answer\"}\n              </Button>\n            </div>\n\n            <div className=\"text-center text-light-100 opacity-60\">OR</div>\n\n            <div className=\"space-y-4\">\n              <Label className=\"text-base font-medium text-light-100\">Type your answer:</Label>\n              <div className=\"card-border\">\n                <div className=\"card\">\n                  <textarea\n                    value={currentAnswer}\n                    onChange={(e) => setCurrentAnswer(e.target.value)}\n                    placeholder=\"Type your detailed answer here...\"\n                    className=\"w-full h-40 p-4 bg-transparent text-light-100 placeholder:text-light-100/50 border-none outline-none resize-none rounded-lg\"\n                    disabled={isRecording}\n                  />\n                </div>\n              </div>\n              <Button onClick={submitTextAnswer} disabled={!currentAnswer.trim() || isLoading || isRecording} className=\"btn-primary w-full py-3 text-lg\">\n                {isLoading ? \"Analyzing Answer...\" : \"Submit Answer\"}\n              </Button>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {feedback && (\n        <div className=\"card-border\">\n          <div className=\"card p-6\">\n            <h3 className=\"text-lg font-semibold mb-4\">Instant Feedback</h3>\n            \n            <div className=\"mb-4\">\n              <h4 className=\"font-semibold text-success-100 mb-1\">Overall Rating: {feedback.rating}/10</h4>\n            </div>\n\n            <div className=\"space-y-4\">\n              <div>\n                <h4 className=\"font-semibold text-success-100 mb-1\">Key Points / Positives:</h4>\n                <ul className=\"space-y-1 text-light-100\">\n                  {feedback.positives.map((p, i) => <li key={i}>• {p}</li>)}\n                </ul>\n              </div>\n\n              <div>\n                <h4 className=\"font-semibold text-destructive-100 mb-1\">Improvements / Suggestions:</h4>\n                <ul className=\"space-y-1 text-light-100\">\n                  {feedback.improvements.map((imp, i) => <li key={i}>• {imp}</li>)}\n                </ul>\n              </div>\n            </div>\n\n            <Button onClick={nextQuestion} className=\"btn-primary w-full mt-6\">Next Question</Button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1670, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/components/ProtectedRoute.tsx"],"sourcesContent":["\"use client\";\r\nimport React, { ReactNode, useEffect } from \"react\";\r\nimport { useRouter } from \"next/navigation\";\r\nimport { useAuth } from \"@/context/AuthContext\";\r\n\r\ninterface ProtectedRouteProps {\r\n  children: ReactNode;\r\n}\r\n\r\nconst ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {\r\n  const { currentUser, loading } = useAuth();\r\n  const router = useRouter();\r\n\r\n  useEffect(() => {\r\n    if (!loading && !currentUser) {\r\n      router.replace(\"/sign-in\");\r\n    }\r\n  }, [loading, currentUser, router]);\r\n\r\n  if (loading) {\r\n    return (\r\n      <div className=\"flex items-center justify-center min-h-screen\">\r\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary\" />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!currentUser) {\r\n    return null; // Optionally, show nothing while redirecting\r\n  }\r\n\r\n  return <>{children}</>;\r\n};\r\n\r\nexport default ProtectedRoute;\r\n"],"names":[],"mappings":";;;;;AACA;AACA;AACA;;;AAHA;;;;AASA,MAAM,iBAAgD;QAAC,EAAE,QAAQ,EAAE;;IACjE,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,GAAG,IAAA,qIAAO;IACxC,MAAM,SAAS,IAAA,kJAAS;IAExB,IAAA,0KAAS;oCAAC;YACR,IAAI,CAAC,WAAW,CAAC,aAAa;gBAC5B,OAAO,OAAO,CAAC;YACjB;QACF;mCAAG;QAAC;QAAS;QAAa;KAAO;IAEjC,IAAI,SAAS;QACX,qBACE,6LAAC;YAAI,WAAU;sBACb,cAAA,6LAAC;gBAAI,WAAU;;;;;;;;;;;IAGrB;IAEA,IAAI,CAAC,aAAa;QAChB,OAAO,MAAM,6CAA6C;IAC5D;IAEA,qBAAO;kBAAG;;AACZ;GAvBM;;QAC6B,qIAAO;QACzB,kJAAS;;;KAFpB;uCAyBS","debugId":null}},
    {"offset": {"line": 1740, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lenovo/OneDrive/Desktop/interview-platform/app/axon/page.tsx"],"sourcesContent":["\"use client\";\n\nimport { useAuth } from \"@/context/AuthContext\";\nimport AxonInterviewPractice from \"@/components/AxonInterviewPractice\";\nimport ProtectedRoute from \"@/components/ProtectedRoute\";\n\nexport default function AxonPage() {\n  const { currentUser } = useAuth();\n\n  return (\n    <ProtectedRoute>\n      <div className=\"root-layout\">\n        {currentUser && (\n          <AxonInterviewPractice \n            userName={currentUser.displayName || currentUser.email || \"User\"} \n            userId={currentUser.uid} \n          />\n        )}\n      </div>\n    </ProtectedRoute>\n  );\n}"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;;;AAJA;;;;AAMe,SAAS;;IACtB,MAAM,EAAE,WAAW,EAAE,GAAG,IAAA,qIAAO;IAE/B,qBACE,6LAAC,2IAAc;kBACb,cAAA,6LAAC;YAAI,WAAU;sBACZ,6BACC,6LAAC,kJAAqB;gBACpB,UAAU,YAAY,WAAW,IAAI,YAAY,KAAK,IAAI;gBAC1D,QAAQ,YAAY,GAAG;;;;;;;;;;;;;;;;AAMnC;GAfwB;;QACE,qIAAO;;;KADT","debugId":null}}]
}